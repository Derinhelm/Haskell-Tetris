
==================== FINAL INTERFACE ====================
2019-03-25 07:49:48.09661154 UTC

interface project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an:MyProj 8063
  interface hash: 683c9748cd0454d144187de0c0b07c4c
  ABI hash: 8faa36c52e5bf079684f9ab94bd9da89
  export-list hash: 8937bf16e9569a4c06b18c3d7cbeb5c5
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7a242ffa3d761dff45aed995f1434522
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  MyProj.changeLandCell
  MyProj.changeLandCellField
  MyProj.checkCanAddFigure
  MyProj.checkCanMoveLeft
  MyProj.checkCanMoveRight
  MyProj.checkCompletedLine
  MyProj.checkFlyCell
  MyProj.countDeletedLines
  MyProj.createCellForMoveLeft
  MyProj.createCellForMoveRight
  MyProj.createCellShiftFigure
  MyProj.createEnd
  MyProj.deleteLineWithNumber
  MyProj.deleteLines
  MyProj.deleteLinesFromField
  MyProj.gameLoop
  MyProj.handleEvent
  MyProj.haveFlyFigure
  MyProj.moveLeft
  MyProj.moveRight
  MyProj.newFigureOnField
  MyProj.newFigureOnGame
  MyProj.numCompLine
  MyProj.shiftFigure
  MyProj.shiftFigureOnField
module dependencies: Constans Draw Type
package dependencies: GLURaw-2.0.0.4 GLUT-2.7.0.14
                      ObjectName-1.1.0.1 OpenGL-3.0.2.2 OpenGLRaw-3.3.2.0
                      StateVar-1.1.1.1 array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bmp-1.2.6.3 bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      fixed-0.2.1.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 gloss-1.13.0.1
                      gloss-rendering-1.13.0.2 half-0.3 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 random-1.1 stm-2.5.0.0 template-haskell-2.14.0.0
                      text-1.2.3.1 time-1.8.0.2
orphans: stm-2.5.0.0:Control.Monad.STM text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic text-1.2.3.1:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type half-0.3:Numeric.Half
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Debug.Trace 6e89d30f3850c77c707392fc46e9b589
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  gloss-1.13.0.1:Graphics.Gloss dc3d422d35cd32353ee5470deb98e8ac
import  -/  gloss-1.13.0.1:Graphics.Gloss.Interface.Pure.Game 3b871ad7b6d70d672603a275ef8ba1e4
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Backend.Types 9cdc96871bc000bfa29ef8cfad3eb219
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Event 70b3da3875a2c6427df4272fec7eb5e1
import  -/  gloss-rendering-1.13.0.2:Graphics.Gloss.Internals.Data.Color 2716426e7777628bb37f6a888abf7b9e
import  -/  Constans 59d04c7a991755b3e63274eef615041f
  exports: 4e851395688f4e2271ad07b9b5734963
  colorBoard a46ee52867c7f2352348479a0f097919
import  -/  Draw d52815c42f40e09882b406393fcd6e46
  exports: 551067e2732157ecbd258059c1ba69cc
import  -/  Type 7992dcfedd7be9017e9d1ad883ec38fc
  exports: 8def765f3fac83615d221720246f91e4
  Cell a490fb91284b41c392b2e9ae69e56c0f
  Cell ce69d132984f15c162cb28e115878ea4
  CoordFigures b3b9710d1bc9d5841b96879fe6ccdd74
  Field cff2286d27e6392df8d5af5cd3f4b99a
  GameState f1548da61a583e6c07d84a70f79e92a7
  GameState 868b64aad4fe42962fd45c408868db30
  Line bec16fc1c01d7327740e42f85f13dafe
  cellColor ce69d132984f15c162cb28e115878ea4
  cellType ce69d132984f15c162cb28e115878ea4
  changeCellInField 26217e12acaf2e7546740dd30e9aeca6
  colorTetr 868b64aad4fe42962fd45c408868db30
  coordTetr 868b64aad4fe42962fd45c408868db30
  endGame 868b64aad4fe42962fd45c408868db30
  funFieldAll f3348f54733fff744c14c483dc51410e
  funFieldAny e2fc49ae8e6e6604234795ccc0087a1c
  funLineAll e24fd0894b0db4c0f3ced2f703c0dbb6
  gameField 868b64aad4fe42962fd45c408868db30
  gameFigures 868b64aad4fe42962fd45c408868db30
  gameRandomGen 868b64aad4fe42962fd45c408868db30
  gameResult 868b64aad4fe42962fd45c408868db30
  getCellColor cbf98000775ec3539180fa3ef9520b83
  getCellType 8a0d3190da84ef6f9cdaf13a11dd13bc
  higherCell d0d89ef5f6f1b1d4b13b6bb2c7192751
  leftCell 1fcd0aeb63942547b516cf8df40bd6a6
  lowerCell b365ab3402e0b802bfae3b031f79a917
  mapField e011b7b413381307ce976d37845fc3d2
  numCell ce69d132984f15c162cb28e115878ea4
  numLine ce69d132984f15c162cb28e115878ea4
  rightCell 98857b461e4106f2a1a231a4d2b3b4d0
  typeCellFromField 21e57c95a2c7b52276682d382c51505d
import  -/  random-1.1:System.Random 8c06dce30a9b8b4f2b7c15fb3f418e08
cd917b6f8bcf6b8aaecc693871acbf44
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MyProj.$trModule3
                   MyProj.$trModule1) -}
637140a171b8785eee75ba9876bdb7d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule2) -}
204fe942f1473ca5b92b79589814a20e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MyProj"#) -}
bd66823722c82efecacae7b7af71d506
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule4) -}
99aa6c486c15517abc54f67dbd421cb5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an"#) -}
af5ca0f5ad40f40a033c1835fe0fad0d
  $wcheckFlyCell ::
    Type.Field
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U><S,1*U><L,1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: Type.Field)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#) ->
                 case ww of wild {
                   DEFAULT
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case ww1 of ww3 { GHC.Types.I# ww4 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w (GHC.Prim.+# wild 1#))
                                  ww4 of wild2 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild3 { GHC.Types.I# x ->
                           case x of wild4 {
                             DEFAULT -> GHC.Types.True 0# -> GHC.Types.False } } } } }
                   14#
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }) -}
eb9094434d5f37e86ea7e6749a252f02
  $wcountDeletedLines :: Type.Field -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2] -}
1124ab1c6920ba6123523f9eb62b0131
  $wgameLoop ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Bool
    -> Type.GameState
  {- Arity: 7, Strictness: <L,U><L,U><L,U><L,U(U)><L,U><L,U><S,1*U>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Bool) ->
                 case ww6 of wild {
                   GHC.Types.False
                   -> case MyProj.haveFlyFigure ww of wild1 {
                        GHC.Types.False
                        -> let {
                             ds :: Type.Field = Type.mapField MyProj.changeLandCellField1 ww
                           } in
                           MyProj.$wnewFigureOnGame
                             (MyProj.deleteLinesFromField ds)
                             ww1
                             ww2
                             (case ww3 of wild2 { GHC.Types.I# x ->
                              case MyProj.$wcountDeletedLines ds 0# of ww7 { DEFAULT ->
                              GHC.Types.I# (GHC.Prim.+# x ww7) } })
                             ww4
                             ww5
                        GHC.Types.True
                        -> Type.GameState
                             (MyProj.shiftFigureOnField ww)
                             ww1
                             ww2
                             ww3
                             ww4
                             ww5
                             GHC.Types.False }
                   GHC.Types.True
                   -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 GHC.Types.True }) -}
cb69aa83bc467da5967d9df60922cde1
  $wnewFigureOnGame ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> Type.GameState
  {- Arity: 6, Strictness: <L,U><L,U><S,1*U><L,U><S,U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color]) ->
                 case ww2 of wild {
                   [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                   : x ds1
                   -> case x of wild1 { GHC.Types.I# x1 ->
                      let {
                        coordNextFigure :: Type.CoordFigures
                        = GHC.List.$w!! @ Type.CoordFigures ww4 (GHC.Prim.-# x1 1#)
                      } in
                      case MyProj.checkCanAddFigure ww coordNextFigure of wild2 {
                        GHC.Types.False
                        -> Debug.Trace.trace
                             @ Type.GameState
                             MyProj.gameLoop1
                             (Type.GameState ww ww1 wild ww3 ww4 ww5 GHC.Types.True)
                        GHC.Types.True
                        -> Type.GameState
                             (MyProj.newFigureOnField
                                ww
                                coordNextFigure
                                (GHC.List.$w!!
                                   @ Graphics.Gloss.Internals.Data.Color.Color
                                   ww5
                                   (GHC.Prim.-# x1 1#)))
                             ww1
                             ds1
                             ww3
                             ww4
                             ww5
                             GHC.Types.False } } }) -}
0d40bfda25685ba7b813a3c913ca2054
  changeLandCell :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U,U,U,U,U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Type.GameState) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ->
                 Type.GameState
                   (MyProj.changeLandCellField ds)
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   GHC.Types.False }) -}
2df8ab02e95c0e2ac2aac1ce417fd7f3
  changeLandCellField :: Type.Field -> Type.Field
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField MyProj.changeLandCellField1 field) -}
6825a11667967758f4fa0ee95835ff85
  changeLandCellField1 :: Type.Cell -> Type.Cell
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(U,U,U(U),U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                 case ds2 of wild1 { GHC.Types.I# ds4 ->
                 case ds4 of ds5 {
                   DEFAULT -> wild
                   1# -> Type.Cell ds ds1 MyProj.changeLandCellField2 ds3 } } }) -}
2922a800fc69ea036734de4abd831bec
  changeLandCellField2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1bf4764c62ddbc7a547d0968e600fc0a
  checkCanAddFigure ::
    Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
83a5cca06100ea5a73cab80ea63b6a86
  checkCanMoveLeft :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveLeft1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
b4b1fdbf102b11a7b9649d59cba9dafe
  checkCanMoveLeft1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.-#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          0#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
8194173daff7b90f001713e810b7e663
  checkCanMoveRight :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveRight1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
9e448c6eea7a143780955aabfb915b95
  checkCanMoveRight1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.+#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          9#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
705725bbbd815a7d144611970661b204
  checkCompletedLine :: Type.Line -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCompletedLine1
                  `cast`
                (<Type.Line>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
40f9ac628034325b8418343ecf294b17
  checkCompletedLine1 :: Type.Line -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (line :: Type.Line) -> MyProj.checkCompletedLine_go line) -}
f44ce856ea9d7b1d4571149fc30aa762
  checkCompletedLine_go :: [Type.Cell] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b578d2e798d5dd14f90efb329e1926d8
  checkFlyCell :: Type.Field -> Type.Cell -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LS(S)L),1*U(1*U(1*U),1*U(U),1*U(1*U),A)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww3 of ww7 { GHC.Types.I# ww8 ->
                 MyProj.$wcheckFlyCell w ww6 ww2 ww8 } } }) -}
80dc3c6a359b2019475bfe931aac6f37
  countDeletedLines :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wcountDeletedLines w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
c38799d9c0e9d35dc03f6697d6a21356
  createCellForMoveLeft :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.+# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveLeft3
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        9#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
09aad780b99117765a977bfb3fa40b3b
  createCellForMoveLeft1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
9ef1dd007f22d55810730485c4f885b3
  createCellForMoveLeft2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
f5a76a1c010407e3b452d147a4752f52
  createCellForMoveLeft3 :: Type.Cell
  {- Strictness: x -}
baf70d744d7bc0233c019ec61a8d1145
  createCellForMoveRight :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.-# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveRight1
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        0#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
61e408f7dd0cd11083f4e1f7369d585e
  createCellForMoveRight1 :: Type.Cell
  {- Strictness: x -}
408d319b697ea54d1f3bbf5c4d91725f
  createCellShiftFigure :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LLL),1*U(U(U),U(U),U(U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of wild {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case GHC.List.$w!!
                             @ Type.Cell
                             (GHC.List.$w!! @ Type.Line w (GHC.Prim.-# wild 1#))
                             ww8 of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 { GHC.Types.I# ds ->
                      case ds of ds7 {
                        DEFAULT -> MyProj.createCellShiftFigure2
                        0# -> Type.Cell (GHC.Types.I# wild) ww7 ww3 ww4
                        1#
                        -> Type.Cell
                             (GHC.Types.I# wild)
                             ww7
                             MyProj.createCellForMoveLeft1
                             ds4
                        2#
                        -> case ww3 of wild3 { GHC.Types.I# ds8 ->
                           case ds8 of ds9 {
                             DEFAULT -> MyProj.createCellShiftFigure1
                             0# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4
                             1#
                             -> Type.Cell
                                  (GHC.Types.I# wild)
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             2# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4 } } } } } }
                   0#
                   -> Type.Cell
                        (GHC.Types.I# 0#)
                        ww2
                        MyProj.createCellForMoveLeft2
                        Graphics.Gloss.Data.Color.white } } }) -}
d2440cc379a9065d6857819b60d0ae72
  createCellShiftFigure1 :: Type.Cell
  {- Strictness: x -}
3373d6a03b48fbb5e29a13076763be5c
  createCellShiftFigure2 :: Type.Cell
  {- Strictness: x -}
716d55e4c123d4a220dd5e2c81637095
  createEnd :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: Type.GameState) -> x) -}
dbb27baa6e81185f1386c22a2875b810
  deleteLineWithNumber :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (field :: Type.Field)
                   (numDeletedLine :: GHC.Types.Int) ->
                 Type.mapField
                   (\ (c :: Type.Cell) ->
                    case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                    case ds of wild1 { GHC.Types.I# x ->
                    case numDeletedLine of wild2 { GHC.Types.I# y ->
                    case GHC.Prim.># x y of lwild {
                      DEFAULT
                      -> case x of wild3 {
                           DEFAULT
                           -> let {
                                hc :: Type.Cell
                                = case ds1 of ww2 { GHC.Types.I# ww3 ->
                                  GHC.List.$w!!
                                    @ Type.Cell
                                    (GHC.List.$w!! @ Type.Line field (GHC.Prim.-# wild3 1#))
                                    ww3 }
                              } in
                              Type.Cell wild1 ds1 (Type.getCellType hc) (Type.getCellColor hc)
                           0#
                           -> Type.Cell
                                wild1
                                ds1
                                MyProj.createCellForMoveLeft2
                                Graphics.Gloss.Data.Color.white }
                      1# -> wild } } } })
                   field) -}
e6a03abe5f8b038b15612e15e7225696
  deleteLines :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U(U),U,U,A)>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 Type.GameState
                   (MyProj.deleteLinesFromField ww1)
                   ww2
                   ww3
                   (case ww4 of wild { GHC.Types.I# x ->
                    case MyProj.$wcountDeletedLines ww1 0# of ww8 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.+# x ww8) } })
                   ww5
                   ww6
                   GHC.Types.False }) -}
03e72ccf25b8d96f60f496b56a2a1440
  deleteLinesFromField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U> -}
723365ab8f67f0e4dd927db85b69f20d
  gameLoop :: GHC.Types.Float -> Type.GameState -> Type.GameState
  {- Arity: 2, Strictness: <L,A><S(LLLLLLS),1*U(U,U,U,U(U),U,U,1*U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 MyProj.$wgameLoop ww1 ww2 ww3 ww4 ww5 ww6 ww7 }) -}
2714efa928a7067334bff003689df877
  gameLoop1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.gameLoop2) -}
9676672856f2618c50207e60dfd42ff1
  gameLoop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("checkEnd"#) -}
5068b60f6445341028eb052b804d4f91
  handleEvent ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState -> Type.GameState
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,U,U,U,U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Graphics.Gloss.Internals.Interface.Event.Event)
                   (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 case w of wild {
                   DEFAULT -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7
                   Graphics.Gloss.Internals.Interface.Event.EventKey ds ds1 ds2 ds3
                   -> case ds of wild1 {
                        DEFAULT -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7
                        Graphics.Gloss.Internals.Interface.Backend.Types.SpecialKey ds4
                        -> case ds4 of wild2 {
                             DEFAULT -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyLeft
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.moveLeft ww1)
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       ww6
                                       GHC.Types.False
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyRight
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.moveRight ww1)
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       ww6
                                       GHC.Types.False
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 } } } } }) -}
e4c2f1257f397aa2536cfd924439f7eb
  haveFlyFigure :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 let {
                   exit :: GHC.Types.Bool <join 0>
                   = (MyProj.haveFlyFigure_go field)
                       `cast`
                     (Data.Semigroup.Internal.N:Any[0])
                 } in
                 letrec {
                   go :: [Type.Line] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       [] -> exit
                       : y ys
                       -> let {
                            exit1 :: GHC.Types.Bool <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> GHC.Types.Bool
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit1
                                : y1 ys1
                                -> case y1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                                   case ww1 of ww5 { GHC.Types.I# ww6 ->
                                   case ww3 of ww7 { GHC.Types.I# ww8 ->
                                   case ww6 of wild2 {
                                     DEFAULT
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1
                                          1#
                                          -> case ww2 of ww9 { GHC.Types.I# ww10 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!!
                                                       @ Type.Line
                                                       field
                                                       (GHC.Prim.+# wild2 1#))
                                                    ww10 of wild4 { Type.Cell ds2 ds3 ds4 ds5 ->
                                             case ds4 of wild5 { GHC.Types.I# x ->
                                             case x of wild6 {
                                               DEFAULT -> go1 ys1 0# -> GHC.Types.False } } } } }
                                     14#
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1 1# -> GHC.Types.False } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
b478cf662d841f3258ead25805c45268
  haveFlyFigure_go :: [Type.Line] -> Data.Semigroup.Internal.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
35fcc85ef18b61c127a5a6b3a6e0992b
  moveLeft :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveLeft1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveLeft field) field }) -}
3360594b534f4aafdbf5a6d012f281cc
  moveRight :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveRight1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveRight field) field }) -}
43b510fedc8d4cac81ad96c4c8f75e60
  newFigureOnField ::
    Type.Field
    -> Type.CoordFigures
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U> -}
8484a86c6ed09a13fa73ce0433ca6cfe
  newFigureOnGame :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S(LLSLSLL),1*U(U,U,1*U,U,U,U,A)>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ->
                 MyProj.$wnewFigureOnGame ww1 ww2 ww3 ww4 ww5 ww6 }) -}
0af320014ee00296db3ba34ba643275e
  numCompLine :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
dc4af15b44e24f784772a22f751dbd1d
  shiftFigure :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Type.GameState) ->
                 case ds of wild { Type.GameState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 Type.GameState
                   (MyProj.shiftFigureOnField ds1)
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   GHC.Types.False }) -}
577b8d6703ec15f8acfa7c3ec2f47c59
  shiftFigureOnField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField
                   (\ (c :: Type.Cell) -> MyProj.createCellShiftFigure field c)
                   field) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

