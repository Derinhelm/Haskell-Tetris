
==================== FINAL INTERFACE ====================
2019-04-02 12:31:57.96697015 UTC

interface project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an:MyProj 8063
  interface hash: 60a6cf0f86f8467352843b4216e297b8
  ABI hash: fe553cfa3dbaee19eba89a912a65eeb1
  export-list hash: d91d4f52041b71e8765c2598e8fcce96
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7a242ffa3d761dff45aed995f1434522
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  MyProj.changeLandCell
  MyProj.changeLandCellField
  MyProj.checkCanAddFigure
  MyProj.checkCanMoveLeft
  MyProj.checkCanMoveRight
  MyProj.checkCanRotate
  MyProj.checkCompletedLine
  MyProj.checkFlyCell
  MyProj.compareFigure
  MyProj.countDeletedLines
  MyProj.createCellForMoveLeft
  MyProj.createCellForMoveRight
  MyProj.createCellShiftFigure
  MyProj.createEnd
  MyProj.createNewCoord
  MyProj.deleteLineWithNumber
  MyProj.deleteLines
  MyProj.deleteLinesFromField
  MyProj.deleteOldCellsForRotate
  MyProj.findCoordFigure
  MyProj.funForSortBy
  MyProj.gameLoop
  MyProj.getCoordsFromCells
  MyProj.handleEvent
  MyProj.haveFlyFigure
  MyProj.moveLeft
  MyProj.moveRight
  MyProj.newFigureOnField
  MyProj.newFigureOnGame
  MyProj.numCompLine
  MyProj.numberNextRotateModel
  MyProj.rotateFigure
  MyProj.runGameLoop
  MyProj.setNewCellsdForRotate
  MyProj.shiftFigure
  MyProj.shiftFigureOnField
  MyProj.update
module dependencies: Constans Draw Type
package dependencies: GLURaw-2.0.0.4 GLUT-2.7.0.14
                      ObjectName-1.1.0.1 OpenGL-3.0.2.2 OpenGLRaw-3.3.2.0
                      StateVar-1.1.1.1 array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bmp-1.2.6.3 bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      fixed-0.2.1.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 gloss-1.13.0.1
                      gloss-rendering-1.13.0.2 half-0.3 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 random-1.1 stm-2.5.0.0 template-haskell-2.14.0.0
                      text-1.2.3.1 time-1.8.0.2
orphans: stm-2.5.0.0:Control.Monad.STM text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic text-1.2.3.1:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type half-0.3:Numeric.Half
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.List ce2c69da408fdc014383cede9e1f9adf
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:Debug.Trace 6e89d30f3850c77c707392fc46e9b589
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  base-4.12.0.0:System.IO 88c2b1c4079c52d62ed362d4eb9a5302
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  gloss-1.13.0.1:Graphics.Gloss dc3d422d35cd32353ee5470deb98e8ac
import  -/  gloss-1.13.0.1:Graphics.Gloss.Interface.Pure.Game 3b871ad7b6d70d672603a275ef8ba1e4
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Backend.Types 9cdc96871bc000bfa29ef8cfad3eb219
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Event 70b3da3875a2c6427df4272fec7eb5e1
import  -/  gloss-rendering-1.13.0.2:Graphics.Gloss.Internals.Data.Color 2716426e7777628bb37f6a888abf7b9e
import  -/  Constans 1487ad15622542e95d86c5deddace10f
  exports: 9c3bf02aef4de5ad20ea7235691d8b63
  colorBoard a46ee52867c7f2352348479a0f097919
import  -/  Draw 4a69272644a6ae6c5141df5a6c8da12d
  exports: a55f534379c28c5818bca346145d53b4
import  -/  Type 69e542a025064bb32c4d37c465067844
  exports: 4305aacaa18c9dc8978b28e0ec454830
  Cell c8163c96363f67f87ceb586115b9036e
  Cell 7b5eee64e5cfbdf155913fb8f6b52292
  CoordCell a84a815ac9d0a4e801bd442bfa023e94
  CoordFigures b3b9710d1bc9d5841b96879fe6ccdd74
  Field 51bd1e0ed49ff3348029661cfe5d0e90
  GameState 914b648e60c50228a360afd0ada31c9c
  GameState 8281b47d2a415f5b18dac47c7056459c
  Line 2e70093aa927aca9064b822e8b9318cc
  cellColor 7b5eee64e5cfbdf155913fb8f6b52292
  cellType 7b5eee64e5cfbdf155913fb8f6b52292
  changeCellInField 52d5b36e05770e075285498a40e7590c
  colorTetr 8281b47d2a415f5b18dac47c7056459c
  coordTetr 8281b47d2a415f5b18dac47c7056459c
  createField c92582258034c2f73ff81b27d5d36ca6
  createRotateModels af3d313dfe42e047578fe9c9778d31f1
  endGame 8281b47d2a415f5b18dac47c7056459c
  findCellCond 9272842dffe03e78d8b0eaa08c533c45
  funFieldAll fdc4ba453f90205fc5bffd9ebe49f735
  funFieldAny 0ee659ee0c80fc62b9ebc53c40cd61d4
  funLineAll 6138127fde49a91fc9d79f4dfe23b96e
  gameField 8281b47d2a415f5b18dac47c7056459c
  gameFigures 8281b47d2a415f5b18dac47c7056459c
  gameRandomGen 8281b47d2a415f5b18dac47c7056459c
  gameResult 8281b47d2a415f5b18dac47c7056459c
  getCell 57cf999e48f69907f6f48e204fc28336
  getCellColor 5be55909eb742937d7b0fd5d40ef1f23
  getCellType af277a1c1243b9128d1aa7d46943ead9
  higherCell e2aa2201d8d99bcc9ae51c2a5011c9c6
  leftCell c99968c45e58a5e2b97b8f9ec817dc49
  lowerCell aa57665d8bd16abfda09769e2dd16c74
  mapField 693a957935306442d057f0c8a080bc19
  numCell 7b5eee64e5cfbdf155913fb8f6b52292
  numLine 7b5eee64e5cfbdf155913fb8f6b52292
  numLoop 8281b47d2a415f5b18dac47c7056459c
  rightCell 0da0f3c453f0bbab689dfd89dfe295d8
  rotateTypeFigure 8281b47d2a415f5b18dac47c7056459c
  typeCellFromField f7a6c7bc3b1b2066a5a167437cb20c59
  userName 8281b47d2a415f5b18dac47c7056459c
cd917b6f8bcf6b8aaecc693871acbf44
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MyProj.$trModule3
                   MyProj.$trModule1) -}
637140a171b8785eee75ba9876bdb7d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule2) -}
204fe942f1473ca5b92b79589814a20e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MyProj"#) -}
bd66823722c82efecacae7b7af71d506
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule4) -}
99aa6c486c15517abc54f67dbd421cb5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an"#) -}
be3a24d9c0c5269235ae08d88ff5f0e6
  $wcheckFlyCell ::
    Type.Field
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U><S,1*U><L,1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: Type.Field)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#) ->
                 case ww of wild {
                   DEFAULT
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case ww1 of ww3 { GHC.Types.I# ww4 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w (GHC.Prim.+# wild 1#))
                                  ww4 of wild2 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild3 { GHC.Types.I# x ->
                           case x of wild4 {
                             DEFAULT -> GHC.Types.True 0# -> GHC.Types.False } } } } }
                   14#
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }) -}
8b9e3c029e9072e507875d501839a8cc
  $wcompareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (# GHC.Types.Int, Type.CoordCell #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U>, Inline: [2] -}
8b6dcee9925aafd5711e72613f525b4b
  $wcountDeletedLines :: Type.Field -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2] -}
015847c4f9b727dc307e513c6252fd3d
  $wcreateNewCoord ::
    GHC.Prim.Int# -> GHC.Types.Int -> GHC.Types.Int -> [Type.CoordCell]
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><L,U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 case MyProj.$wnumberNextRotateModel ww of ww3 { DEFAULT ->
                 case GHC.List.$w!!
                        @ (Type.CoordFigures, Type.CoordCell)
                        Type.createRotateModels
                        ww3 of wild { (,) x ds1 ->
                 GHC.Base.map
                   @ (GHC.Types.Int, GHC.Types.Int)
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (\ (coordNewModel :: (GHC.Types.Int, GHC.Types.Int)) ->
                    (case ww1 of wild1 { GHC.Types.I# x1 ->
                     case ds1 of wild2 { (,) x2 ds2 ->
                     case x2 of wild3 { GHC.Types.I# y ->
                     case coordNewModel of wild4 { (,) x3 ds3 ->
                     case x3 of wild5 { GHC.Types.I# y1 ->
                     GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y) y1) } } } } },
                     case ww2 of wild1 { GHC.Types.I# x1 ->
                     case ds1 of wild2 { (,) ds2 y ->
                     case y of wild3 { GHC.Types.I# y1 ->
                     case coordNewModel of wild4 { (,) ds3 y2 ->
                     case y2 of wild5 { GHC.Types.I# y3 ->
                     GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y1) y3) } } } } }))
                   x } }) -}
e0361ca2cb43e11920a613d480123496
  $wdeleteOldCellsForRotate ::
    [Type.CoordCell] -> Type.Field -> Type.Field
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
810d7ef06b844609a6cb66661855cc60
  $wfunForSortBy ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><S,U><L,1*U(U)><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww1 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww1 of lwild1 {
                        DEFAULT -> GHC.Types.GT
                        1#
                        -> case ww2 of wild { GHC.Types.I# x ->
                           case ww3 of wild1 { GHC.Types.I# y ->
                           case GHC.Prim.<# x y of lwild2 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.LT } } } }
                   1# -> GHC.Types.LT }) -}
fbabcfd3913ecc994b175d1e36b3a096
  $wnumberNextRotateModel :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case ww of ds {
                   DEFAULT -> GHC.Prim.+# ds 1#
                   0# -> 0#
                   4# -> 1#
                   8# -> 5#
                   12# -> 9#
                   16# -> 13#
                   20# -> 17#
                   24# -> 21#
                   28# -> 25# }) -}
e612f57633ca0dd034beae414133ea28
  $wrotateFigure :: Type.Field -> GHC.Prim.Int# -> Type.Field
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: Type.Field) (ww :: GHC.Prim.Int#) ->
                 let {
                   oldCoord :: Type.CoordFigures
                   = MyProj.getCoordsFromCells
                       (Type.findCellCond
                          w
                          MyProj.findCoordFigure1
                          (GHC.Types.[] @ Type.Cell))
                       (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))
                 } in
                 let {
                   ds :: (GHC.Types.Int, GHC.Types.Int)
                   = case GHC.List.$w!!
                            @ (Type.CoordFigures, Type.CoordCell)
                            Type.createRotateModels
                            ww of wild { (,) ds1 y ->
                     y }
                 } in
                 let {
                   newCoord :: [Type.CoordCell]
                   = MyProj.$wcreateNewCoord
                       ww
                       (case GHC.Base.map
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               (Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int)
                               oldCoord of wild {
                          [] -> GHC.List.minimum2
                          : ipv ipv1
                          -> case ipv of ww1 { GHC.Types.I# ww2 ->
                             case GHC.List.$wgo1 ipv1 ww2 of ww3 { DEFAULT ->
                             case ds of wild1 { (,) oldRelMainX oldRelMainY ->
                             case oldRelMainX of wild2 { GHC.Types.I# y ->
                             GHC.Types.I# (GHC.Prim.+# ww3 y) } } } } })
                       (case GHC.Base.map
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               (Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int)
                               oldCoord of wild {
                          [] -> GHC.List.minimum2
                          : ipv ipv1
                          -> case ipv of ww1 { GHC.Types.I# ww2 ->
                             case GHC.List.$wgo1 ipv1 ww2 of ww3 { DEFAULT ->
                             case ds of wild1 { (,) oldRelMainX oldRelMainY ->
                             case oldRelMainY of wild2 { GHC.Types.I# y ->
                             GHC.Types.I# (GHC.Prim.+# ww3 y) } } } } })
                 } in
                 let {
                   fieldDeletedOldCells :: Type.Field
                   = MyProj.$wdeleteOldCellsForRotate oldCoord w
                 } in
                 case MyProj.checkCanRotate fieldDeletedOldCells newCoord of wild {
                   GHC.Types.False -> w
                   GHC.Types.True
                   -> MyProj.setNewCellsdForRotate
                        newCoord
                        (case oldCoord of wild1 {
                           []
                           -> case GHC.List.badHead
                              ret_ty Graphics.Gloss.Internals.Data.Color.Color
                              of {}
                           : x ds1
                           -> case x of wild2 { (,) ds2 y ->
                              case y of ww1 { GHC.Types.I# ww2 ->
                              case ds2 of ww3 { GHC.Types.I# ww4 ->
                              case GHC.List.$w!!
                                     @ Type.Cell
                                     (GHC.List.$w!! @ Type.Line w ww4)
                                     ww2 of wild3 { Type.Cell ds3 ds4 ds5 ds6 ->
                              ds6 } } } } })
                        fieldDeletedOldCells }) -}
ce9c26fb31406eb0510d2e718509984e
  $wupdate ::
    GHC.Base.String
    -> Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 10,
     Strictness: <L,U><L,U><L,U><L,U><L,U(U)><L,U><L,U><L,U(U)><L,U><L,U(U)>,
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: Type.Field)
                   (ww2 :: System.Random.StdGen)
                   (ww3 :: [Type.NumberFigure])
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: [Type.CoordFigures])
                   (ww6 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww7 :: GHC.Types.Int)
                   (ww8 :: GHC.Types.Int)
                   (ww9 :: GHC.Types.Int) ->
                 MyProj.runGameLoop1
                   (case ww9 of wild { GHC.Types.I# i ->
                    let {
                      x :: GHC.Prim.Double#
                      = GHC.Prim.+##
                          (GHC.Prim./## (GHC.Prim.int2Double# i) 30.0##)
                          1.0e-4##
                    } in
                    let {
                      n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                    } in
                    case GHC.Prim.<## (GHC.Prim.int2Double# n) x of lwild {
                      DEFAULT
                      -> case GHC.Prim.<=# n 3# of lwild1 {
                           DEFAULT -> MyProj.update1 1# -> GHC.Types.I# n }
                      1#
                      -> let {
                           x1 :: GHC.Prim.Int# = GHC.Prim.+# n 1#
                         } in
                         case GHC.Prim.<=# x1 3# of lwild1 {
                           DEFAULT -> MyProj.update1 1# -> GHC.Types.I# x1 } } })
                   (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    (# s, Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 #))
                     `cast`
                   (Sym (GHC.Types.N:IO[0] <Type.GameState>_R))) -}
542a109fbabff88b51fc075eeb041685
  changeLandCell :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,1*U,U,U,U,U,U,A,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Type.GameState) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 Type.GameState
                   ds
                   (MyProj.changeLandCellField ds1)
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   MyProj.changeLandCell1
                   ds8
                   ds9 }) -}
8d1e2230c7c1ac99c035f348f6573163
  changeLandCell1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
593b9a2fd34cf0a744e2b53ece2e7118
  changeLandCellField :: Type.Field -> Type.Field
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField MyProj.changeLandCellField1 field) -}
a14ff90c89ebd23626627f3e6943d49e
  changeLandCellField1 :: Type.Cell -> Type.Cell
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(U,U,U(U),U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                 case ds2 of wild1 { GHC.Types.I# ds4 ->
                 case ds4 of ds5 {
                   DEFAULT -> wild
                   1# -> Type.Cell ds ds1 MyProj.changeLandCell1 ds3 } } }) -}
728b8863385ce1606cce1e55e09c607b
  checkCanAddFigure ::
    Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
96d5e75df10ef2f1aa5f2d111b67170c
  checkCanMoveLeft :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveLeft1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
022b725c5e291433156183d2cc3db25b
  checkCanMoveLeft1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.-#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          0#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
e676bb1fedefafd4985f9211d7128840
  checkCanMoveRight :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveRight1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
5d5b29a07f025ed55038d2f26b4b72e4
  checkCanMoveRight1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.+#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          9#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
1e9c8f80c2ad6a06fe04af2f4c934ccb
  checkCanRotate :: Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
37edc73ec2e7fb1fcd03a38b85cfce5d
  checkCompletedLine :: Type.Line -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCompletedLine1
                  `cast`
                (<Type.Line>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
0e28ba4af8da403bd3efd6345677c382
  checkCompletedLine1 :: Type.Line -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (line :: Type.Line) -> MyProj.checkCompletedLine_go line) -}
de46cd151b657903eaa753cb0ee8f6bc
  checkCompletedLine_go :: [Type.Cell] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
1534115537dfa97d8f4ed9e7e4c661e6
  checkFlyCell :: Type.Field -> Type.Cell -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LS(S)L),1*U(1*U(1*U),1*U(U),1*U(1*U),A)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww3 of ww7 { GHC.Types.I# ww8 ->
                 MyProj.$wcheckFlyCell w ww6 ww2 ww8 } } }) -}
50cd01ae679e71c56fc626a5d5626e7d
  compareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (GHC.Types.Int, Type.CoordCell)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Type.CoordFigures)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [(Type.CoordFigures, Type.CoordCell)]) ->
                 case MyProj.$wcompareFigure w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
3052e6a4fd632d82d1e0b32ce634bc01
  countDeletedLines :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wcountDeletedLines w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
e5a403f07390edbe563f5cdb80a628c4
  createCellForMoveLeft :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.+# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveLeft3
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        9#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
09aad780b99117765a977bfb3fa40b3b
  createCellForMoveLeft1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
9ef1dd007f22d55810730485c4f885b3
  createCellForMoveLeft2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
070e0c47483178eab53940fa484bb922
  createCellForMoveLeft3 :: Type.Cell
  {- Strictness: x -}
5b491b43c2dfc28da10b38d3c2bbc82f
  createCellForMoveRight :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.-# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveRight1
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        0#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
787bc45a3ba4640e6fd49d5f2d5ee85d
  createCellForMoveRight1 :: Type.Cell
  {- Strictness: x -}
cac6876fb5b9e110e98b5bea1c8fd6fa
  createCellShiftFigure :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LLL),1*U(U(U),U(U),U(U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of wild {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case GHC.List.$w!!
                             @ Type.Cell
                             (GHC.List.$w!! @ Type.Line w (GHC.Prim.-# wild 1#))
                             ww8 of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 { GHC.Types.I# ds ->
                      case ds of ds7 {
                        DEFAULT -> MyProj.createCellShiftFigure2
                        0# -> Type.Cell (GHC.Types.I# wild) ww7 ww3 ww4
                        1#
                        -> Type.Cell
                             (GHC.Types.I# wild)
                             ww7
                             MyProj.createCellForMoveLeft1
                             ds4
                        2#
                        -> case ww3 of wild3 { GHC.Types.I# ds8 ->
                           case ds8 of ds9 {
                             DEFAULT -> MyProj.createCellShiftFigure1
                             0# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4
                             1#
                             -> Type.Cell
                                  (GHC.Types.I# wild)
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             2# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4 } } } } } }
                   0#
                   -> Type.Cell
                        (GHC.Types.I# 0#)
                        ww2
                        MyProj.createCellForMoveLeft2
                        Graphics.Gloss.Data.Color.white } } }) -}
4a5946fda96e9fc72141933ac50039c9
  createCellShiftFigure1 :: Type.Cell
  {- Strictness: x -}
be56fb3bcff9e1e7a7d2665643ac36bf
  createCellShiftFigure2 :: Type.Cell
  {- Strictness: x -}
f62e9f7e9cd19c94529f0c3ade5fde1d
  createEnd :: Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 2,
     Strictness: <S(LLLLLLLS(S)LL),1*U(U,U,U,U,U(U),U,U,U(U),U,U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.createEnd1
                  `cast`
                (<Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
d0b3543b6a0cbb8beaf7e485c94de905
  createEnd1 ::
    Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 2,
     Strictness: <S(LLLLLLLS(S)LL),1*U(U,U,U,U,U(U),U,U,U(U),U,U)><S,U>,
     Unfolding: (\ (game :: Type.GameState)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 case ds7 of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> (# eta, wild #)
                   1#
                   -> case System.IO.appendFile2
                             @ ()
                             MyProj.createEnd5
                             GHC.IO.IOMode.AppendMode
                             (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot] ->
                              GHC.IO.Handle.Text.hPutStr'
                                hdl
                                (GHC.Base.++_$s++
                                   @ GHC.Types.Char
                                   (GHC.CString.unpackAppendCString#
                                      MyProj.createEnd4
                                      (case ds4 of ww2 { GHC.Types.I# ww3 ->
                                       case GHC.Show.$wshowSignedInt
                                              0#
                                              ww3
                                              (GHC.Types.[]
                                                 @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                       GHC.Base.++_$s++
                                         @ GHC.Types.Char
                                         MyProj.createEnd2
                                         ww5
                                         ww6 } }))
                                   GHC.Show.$fShow(,)3
                                   (GHC.Show.showLitString ds GHC.Show.$fShow[]1))
                                GHC.Types.False)
                             eta of ds10 { (#,#) ipv ipv1 ->
                      (# ipv,
                         Type.GameState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           MyProj.createCellForMoveLeft2
                           ds8
                           ds9 #) } } } }) -}
2c3e7d4fcb7974bfee20cf821e1c5368
  createEnd2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.createEnd3) -}
1172a44825b6cca46e43ce4398da356d
  createEnd3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
dfa5eefac29c8612569471676d292357
  createEnd4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" - "#) -}
73fac93f872850ffd99ffb80fef5ab63
  createEnd5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.createEnd6) -}
bd56e965735cb362f91ee29a97ffdf00
  createEnd6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("result"#) -}
83c85be617c8d42dd5dd2f4c832ef00a
  createNewCoord ::
    GHC.Types.Int -> Type.CoordCell -> [Type.CoordCell]
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,1*U(U(U),U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Type.CoordCell) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { (,) ww3 ww4 ->
                 MyProj.$wcreateNewCoord ww1 ww3 ww4 } }) -}
6a3c51654a867ae303912ea608f3a6c6
  deleteLineWithNumber :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (field :: Type.Field)
                   (numDeletedLine :: GHC.Types.Int) ->
                 Type.mapField
                   (\ (c :: Type.Cell) ->
                    case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                    case ds of wild1 { GHC.Types.I# x ->
                    case numDeletedLine of wild2 { GHC.Types.I# y ->
                    case GHC.Prim.># x y of lwild {
                      DEFAULT
                      -> case x of wild3 {
                           DEFAULT
                           -> let {
                                hc :: Type.Cell
                                = case ds1 of ww2 { GHC.Types.I# ww3 ->
                                  GHC.List.$w!!
                                    @ Type.Cell
                                    (GHC.List.$w!! @ Type.Line field (GHC.Prim.-# wild3 1#))
                                    ww3 }
                              } in
                              Type.Cell wild1 ds1 (Type.getCellType hc) (Type.getCellColor hc)
                           0#
                           -> Type.Cell
                                wild1
                                ds1
                                MyProj.createCellForMoveLeft2
                                Graphics.Gloss.Data.Color.white }
                      1# -> wild } } } })
                   field) -}
59761769e53c510095657b856eaf7aeb
  deleteLines :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,1*U(U),U,U,A,U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 Type.GameState
                   ww1
                   (MyProj.deleteLinesFromField ww2)
                   ww3
                   ww4
                   (case ww5 of wild { GHC.Types.I# x ->
                    case MyProj.$wcountDeletedLines ww2 0# of ww11 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.+# x ww11) } })
                   ww6
                   ww7
                   MyProj.changeLandCell1
                   ww9
                   ww10 }) -}
d2649492d033bc0e4f16e3d902e5fea9
  deleteLinesFromField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U> -}
2a70d3aa09e3982d2749cb1e3fd494eb
  deleteOldCellsForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,A><L,U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [Type.CoordCell])
                   (w1 :: Graphics.Gloss.Internals.Data.Color.Color)
                   (w2 :: Type.Field) ->
                 MyProj.$wdeleteOldCellsForRotate w w2) -}
00986b1c047636740f53330c338391b4
  findCoordFigure :: Type.Field -> Type.CoordFigures
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 MyProj.getCoordsFromCells
                   (Type.findCellCond
                      field
                      MyProj.findCoordFigure1
                      (GHC.Types.[] @ Type.Cell))
                   (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))) -}
51e1eb3986613fc5a1ddd2076c91a26c
  findCoordFigure1 :: Type.Cell -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(A,A,1*U(1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds1 ds2 ds3 ds4 ->
                 case ds3 of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } } }) -}
ac17f82765c06cfcb67bf68f1b7c15c4
  funForSortBy ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int))
                   (w1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { (,) ww8 ww9 ->
                 MyProj.$wfunForSortBy ww4 ww6 ww8 ww9 } } } }) -}
4cbd96262ecad27047e0271ccadc4f7a
  gameLoop ::
    GHC.Types.IO Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 2,
     Strictness: <C(S(SS(LLLLLLLS(S)LL))),1*C1(U(U,1*U(U,U,U,U,U(U),U,U,U(U),U,U(U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.gameLoop1
                  `cast`
                (<GHC.Types.IO Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
edadc5a91172c05747ad0101e846ff9b
  gameLoop1 ::
    GHC.Types.IO Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 2,
     Strictness: <C(S(SS(LLLLLLLS(S)LL))),1*C1(U(U,1*U(U,U,U,U,U(U),U,U,U(U),U,U(U))))><S,U>,
     Unfolding: (\ (g :: GHC.Types.IO Type.GameState)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case g `cast` (GHC.Types.N:IO[0] <Type.GameState>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Type.GameState ds ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 case ds8 of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> MyProj.createEnd1 wild ipv
                   0#
                   -> case MyProj.haveFlyFigure ds2 of wild3 {
                        GHC.Types.False
                        -> (# ipv,
                              case ds4 of wild4 {
                                [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                                : x1 ds11
                                -> case x1 of ww { GHC.Types.I# ww1 ->
                                   let {
                                     coordNextFigure :: Type.CoordFigures
                                     = GHC.List.$w!! @ Type.CoordFigures ds6 ww1
                                   } in
                                   let {
                                     ds12 :: Type.Field
                                     = Type.mapField MyProj.changeLandCellField1 ds2
                                   } in
                                   let {
                                     ww2 :: Type.Field = MyProj.deleteLinesFromField ds12
                                   } in
                                   let {
                                     ww3 :: GHC.Types.Int
                                     = case ds5 of wild5 { GHC.Types.I# x2 ->
                                       case MyProj.$wcountDeletedLines ds12 0# of ww4 { DEFAULT ->
                                       GHC.Types.I# (GHC.Prim.+# x2 ww4) } }
                                   } in
                                   case MyProj.checkCanAddFigure ww2 coordNextFigure of wild5 {
                                     GHC.Types.False
                                     -> Type.GameState
                                          ds
                                          ww2
                                          ds3
                                          wild4
                                          ww3
                                          ds6
                                          ds7
                                          MyProj.createCellForMoveLeft1
                                          ds9
                                          (case ds10 of wild6 { GHC.Types.I# x2 ->
                                           GHC.Types.I# (GHC.Prim.+# x2 1#) })
                                     GHC.Types.True
                                     -> Type.GameState
                                          ds
                                          (MyProj.newFigureOnField
                                             ww2
                                             coordNextFigure
                                             (GHC.List.$w!!
                                                @ Graphics.Gloss.Internals.Data.Color.Color
                                                ds7
                                                ww1))
                                          ds3
                                          ds11
                                          ww3
                                          ds6
                                          ds7
                                          MyProj.changeLandCell1
                                          (case ww1 of wild6 {
                                             DEFAULT
                                             -> GHC.Types.I# (GHC.Prim.-# (GHC.Prim.*# wild6 4#) 3#)
                                             0# -> MyProj.changeLandCell1 })
                                          (case ds10 of wild6 { GHC.Types.I# x2 ->
                                           GHC.Types.I# (GHC.Prim.+# x2 1#) }) } } } #)
                        GHC.Types.True
                        -> (# ipv,
                              Type.GameState
                                ds
                                (MyProj.shiftFigureOnField ds2)
                                ds3
                                ds4
                                ds5
                                ds6
                                ds7
                                MyProj.changeLandCell1
                                ds9
                                (case ds10 of wild4 { GHC.Types.I# x1 ->
                                 GHC.Types.I# (GHC.Prim.+# x1 1#) }) #) } } } } }) -}
c478cbc8e0b505f7be1217720c87e338
  getCoordsFromCells ::
    [Type.Cell]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
c8f3b8fd7e93ddb2059f4403feaf7234
  handleEvent ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U,U,U,U,U,U,U,U(U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.handleEvent1
                  `cast`
                (<Graphics.Gloss.Internals.Interface.Event.Event>_R
                 ->_R <Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
9afabb22a11be112d40eb561bcfa4662
  handleEvent1 ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U,U,U,U,U,U,U,U(U),U)><S,U>,
     Unfolding: (\ (ds :: Graphics.Gloss.Internals.Interface.Event.Event)
                   (game :: Type.GameState)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ds of wild {
                   DEFAULT -> (# eta, game #)
                   Graphics.Gloss.Internals.Interface.Event.EventKey ds1 ds2 ds3 ds4
                   -> case ds1 of wild1 {
                        DEFAULT -> (# eta, game #)
                        Graphics.Gloss.Internals.Interface.Backend.Types.SpecialKey ds5
                        -> case ds5 of wild2 {
                             DEFAULT -> (# eta, game #)
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyUp
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     (# eta,
                                        Type.GameState
                                          ds6
                                          (MyProj.rotateFigure ds7 ds14)
                                          ds8
                                          ds9
                                          ds10
                                          ds11
                                          ds12
                                          MyProj.changeLandCell1
                                          (MyProj.numberNextRotateModel ds14)
                                          ds15 #) }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyLeft
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     (# eta,
                                        Type.GameState
                                          ds6
                                          (MyProj.moveLeft ds7)
                                          ds8
                                          ds9
                                          ds10
                                          ds11
                                          ds12
                                          MyProj.changeLandCell1
                                          ds14
                                          ds15 #) }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyRight
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     (# eta,
                                        Type.GameState
                                          ds6
                                          (MyProj.moveRight ds7)
                                          ds8
                                          ds9
                                          ds10
                                          ds11
                                          ds12
                                          MyProj.changeLandCell1
                                          ds14
                                          ds15 #) }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyEnter
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     (# eta,
                                        Type.GameState
                                          ds6
                                          Type.createField
                                          ds8
                                          (case ds9 of wild5 {
                                             []
                                             -> case GHC.List.scanl2
                                                ret_ty [Type.NumberFigure]
                                                of {}
                                             : ds16 xs
                                             -> case xs of wild6 {
                                                  [] -> GHC.List.scanl2 @ Type.NumberFigure
                                                  : ds17 xs1 -> xs1 } })
                                          MyProj.changeLandCell1
                                          ds11
                                          ds12
                                          MyProj.changeLandCell1
                                          MyProj.handleEvent2
                                          MyProj.changeLandCell1 #) }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) } } } }) -}
7a87d2fcae9dd9448fdb7e26d7e84dca
  handleEvent2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 28#) -}
83fb72c12e4aee3e91db4ca07eaf7258
  haveFlyFigure :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 let {
                   exit :: GHC.Types.Bool <join 0>
                   = (MyProj.haveFlyFigure_go field)
                       `cast`
                     (Data.Semigroup.Internal.N:Any[0])
                 } in
                 letrec {
                   go :: [Type.Line] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       [] -> exit
                       : y ys
                       -> let {
                            exit1 :: GHC.Types.Bool <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> GHC.Types.Bool
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit1
                                : y1 ys1
                                -> case y1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                                   case ww1 of ww5 { GHC.Types.I# ww6 ->
                                   case ww3 of ww7 { GHC.Types.I# ww8 ->
                                   case ww6 of wild2 {
                                     DEFAULT
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1
                                          1#
                                          -> case ww2 of ww9 { GHC.Types.I# ww10 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!!
                                                       @ Type.Line
                                                       field
                                                       (GHC.Prim.+# wild2 1#))
                                                    ww10 of wild4 { Type.Cell ds2 ds3 ds4 ds5 ->
                                             case ds4 of wild5 { GHC.Types.I# x ->
                                             case x of wild6 {
                                               DEFAULT -> go1 ys1 0# -> GHC.Types.False } } } } }
                                     14#
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1 1# -> GHC.Types.False } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
459a2646a39a9274b3f7b4d622b37cf4
  haveFlyFigure_go :: [Type.Line] -> Data.Semigroup.Internal.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
945b5395772fe04a76fefe5c7504c4f9
  moveLeft :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveLeft1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveLeft field) field }) -}
eeceacb65ca68a1a522227b961bd1b85
  moveRight :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveRight1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveRight field) field }) -}
05cd8a1a3ab94269d44cec72ceda678a
  newFigureOnField ::
    Type.Field
    -> Type.CoordFigures
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U> -}
e9da30c8d8bfd5ce71ba1454ae73592b
  newFigureOnGame :: Type.GameState -> Type.GameState
  {- Arity: 1,
     Strictness: <S(LLLSLSLLLL),1*U(U,U,U,1*U,U,U,U,A,U,1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 case ww4 of wild {
                   [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                   : x ds1
                   -> case x of ww11 { GHC.Types.I# ww12 ->
                      let {
                        coordNextFigure :: Type.CoordFigures
                        = GHC.List.$w!! @ Type.CoordFigures ww6 ww12
                      } in
                      case MyProj.checkCanAddFigure ww2 coordNextFigure of wild1 {
                        GHC.Types.False
                        -> Type.GameState
                             ww1
                             ww2
                             ww3
                             wild
                             ww5
                             ww6
                             ww7
                             MyProj.createCellForMoveLeft1
                             ww9
                             (case ww10 of wild2 { GHC.Types.I# x1 ->
                              GHC.Types.I# (GHC.Prim.+# x1 1#) })
                        GHC.Types.True
                        -> Type.GameState
                             ww1
                             (MyProj.newFigureOnField
                                ww2
                                coordNextFigure
                                (GHC.List.$w!!
                                   @ Graphics.Gloss.Internals.Data.Color.Color
                                   ww7
                                   ww12))
                             ww3
                             ds1
                             ww5
                             ww6
                             ww7
                             MyProj.changeLandCell1
                             (case ww12 of wild2 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.-# (GHC.Prim.*# wild2 4#) 3#)
                                0# -> MyProj.changeLandCell1 })
                             (case ww10 of wild2 { GHC.Types.I# x1 ->
                              GHC.Types.I# (GHC.Prim.+# x1 1#) }) } } } }) -}
6b04e73a25f055ba4b6bab5f2949986b
  numCompLine :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
a86d715edde92dd4d3fa92939bb7c9d7
  numberNextRotateModel :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wnumberNextRotateModel ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
f83355ad706afe07bacef3e5f0c77110
  rotateFigure :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 MyProj.$wrotateFigure w ww1 }) -}
c458c8b7d77cba7d3c6dbdeb5349dad5
  runGameLoop ::
    GHC.Types.Int
    -> GHC.Types.IO Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 3,
     Strictness: <L,1*U(1*U)><C(S(SS)),C(U(U,U(U,U,U,U,U(U),U,U,U(U),U,U(U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.runGameLoop1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.IO Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
a624ce5071976a1860ba44a623c83c3f
  runGameLoop1 ::
    GHC.Types.Int
    -> GHC.Types.IO Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 3,
     Strictness: <L,1*U(1*U)><C(S(SS)),C(U(U,U(U,U,U,U,U(U),U,U,U(U),U,U(U))))><S,U> -}
d5d63a2d123a3e420d273ae9fbf61bda
  setNewCellsdForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
bdaa58d802a3057a71977deac9293559
  shiftFigure :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,U,A,U,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Type.GameState) ->
                 case ds of wild { Type.GameState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 Type.GameState
                   ds1
                   (MyProj.shiftFigureOnField ds2)
                   ds3
                   ds4
                   ds5
                   ds6
                   ds7
                   MyProj.changeLandCell1
                   ds9
                   (case ds10 of wild1 { GHC.Types.I# x ->
                    GHC.Types.I# (GHC.Prim.+# x 1#) }) }) -}
6f35a6d837a82a5eddf993f2f2b2ec17
  shiftFigureOnField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField
                   (\ (c :: Type.Cell) -> MyProj.createCellShiftFigure field c)
                   field) -}
add8a4afa1a6862dc4cbaedd04837d65
  update ::
    GHC.Types.Float -> Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 2,
     Strictness: <L,A><S,1*U(U,U,U,U,U(U),U,U,U(U),U,U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 (MyProj.$wupdate ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10)
                   `cast`
                 (Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) }) -}
7b10673455fa3e0c90d4b5e309e6c905
  update1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

