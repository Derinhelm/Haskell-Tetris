
==================== FINAL INTERFACE ====================
2019-03-30 10:37:50.37113537 UTC

interface project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an:MyProj 8063
  interface hash: f927e5bd160943825fb5aff6112983a3
  ABI hash: c6f5eb1f509316972026c50cb0a74cea
  export-list hash: d91d4f52041b71e8765c2598e8fcce96
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7a242ffa3d761dff45aed995f1434522
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  MyProj.changeLandCell
  MyProj.changeLandCellField
  MyProj.checkCanAddFigure
  MyProj.checkCanMoveLeft
  MyProj.checkCanMoveRight
  MyProj.checkCanRotate
  MyProj.checkCompletedLine
  MyProj.checkFlyCell
  MyProj.compareFigure
  MyProj.countDeletedLines
  MyProj.createCellForMoveLeft
  MyProj.createCellForMoveRight
  MyProj.createCellShiftFigure
  MyProj.createEnd
  MyProj.createNewCoord
  MyProj.deleteLineWithNumber
  MyProj.deleteLines
  MyProj.deleteLinesFromField
  MyProj.deleteOldCellsForRotate
  MyProj.findCoordFigure
  MyProj.funForSortBy
  MyProj.gameLoop
  MyProj.getCoordsFromCells
  MyProj.handleEvent
  MyProj.haveFlyFigure
  MyProj.moveLeft
  MyProj.moveRight
  MyProj.newFigureOnField
  MyProj.newFigureOnGame
  MyProj.numCompLine
  MyProj.numberNextRotateModel
  MyProj.rotateFigure
  MyProj.runGameLoop
  MyProj.setNewCellsdForRotate
  MyProj.shiftFigure
  MyProj.shiftFigureOnField
  MyProj.update
module dependencies: Constans Draw Type
package dependencies: GLURaw-2.0.0.4 GLUT-2.7.0.14
                      ObjectName-1.1.0.1 OpenGL-3.0.2.2 OpenGLRaw-3.3.2.0
                      StateVar-1.1.1.1 array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bmp-1.2.6.3 bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      fixed-0.2.1.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 gloss-1.13.0.1
                      gloss-rendering-1.13.0.2 half-0.3 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 random-1.1 stm-2.5.0.0 template-haskell-2.14.0.0
                      text-1.2.3.1 time-1.8.0.2
orphans: stm-2.5.0.0:Control.Monad.STM text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic text-1.2.3.1:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type half-0.3:Numeric.Half
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.List ce2c69da408fdc014383cede9e1f9adf
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:Debug.Trace 6e89d30f3850c77c707392fc46e9b589
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  gloss-1.13.0.1:Graphics.Gloss dc3d422d35cd32353ee5470deb98e8ac
import  -/  gloss-1.13.0.1:Graphics.Gloss.Interface.Pure.Game 3b871ad7b6d70d672603a275ef8ba1e4
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Backend.Types 9cdc96871bc000bfa29ef8cfad3eb219
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Event 70b3da3875a2c6427df4272fec7eb5e1
import  -/  gloss-rendering-1.13.0.2:Graphics.Gloss.Internals.Data.Color 2716426e7777628bb37f6a888abf7b9e
import  -/  Constans 1487ad15622542e95d86c5deddace10f
  exports: 9c3bf02aef4de5ad20ea7235691d8b63
  colorBoard a46ee52867c7f2352348479a0f097919
  createListFigures b0f2ada2af994bcf86bb18480b385de4
import  -/  Draw 92609ded0e30964a65da04bdaf7f6916
  exports: a55f534379c28c5818bca346145d53b4
import  -/  Type 4be64289e30fb0c6ac242b21363dca34
  exports: 842f1aef9b69bafc2d18e10cc7c9cc54
  Cell a490fb91284b41c392b2e9ae69e56c0f
  Cell ce69d132984f15c162cb28e115878ea4
  CoordCell a84a815ac9d0a4e801bd442bfa023e94
  CoordFigures b3b9710d1bc9d5841b96879fe6ccdd74
  Field cff2286d27e6392df8d5af5cd3f4b99a
  GameState 3fa26fe2516dc355a97b89b2c0f6b3fd
  GameState 6259977f3c94283e5ea8292c918bcb53
  Line bec16fc1c01d7327740e42f85f13dafe
  cellColor ce69d132984f15c162cb28e115878ea4
  cellType ce69d132984f15c162cb28e115878ea4
  changeCellInField 26217e12acaf2e7546740dd30e9aeca6
  colorTetr 6259977f3c94283e5ea8292c918bcb53
  coordTetr 6259977f3c94283e5ea8292c918bcb53
  createColorFigures 9a9effe73c0937dbbffff73fdc6b19e2
  createCoordFigures c6aeabd63007d112aff70ef8b7e46514
  createField 5837a6a3357dcf1de5c58ee8c39686ba
  createRotateModels 107d5c7881a9520afd9276970a576ce6
  endGame 6259977f3c94283e5ea8292c918bcb53
  findCellCond 23c0104d27cbb4885b4db356b48a4902
  funFieldAll f3348f54733fff744c14c483dc51410e
  funFieldAny e2fc49ae8e6e6604234795ccc0087a1c
  funLineAll e24fd0894b0db4c0f3ced2f703c0dbb6
  gameField 6259977f3c94283e5ea8292c918bcb53
  gameFigures 6259977f3c94283e5ea8292c918bcb53
  gameRandomGen 6259977f3c94283e5ea8292c918bcb53
  gameResult 6259977f3c94283e5ea8292c918bcb53
  getCell e0b0d74dc81858d2413e5fb147c7c3a8
  getCellColor cbf98000775ec3539180fa3ef9520b83
  getCellType 8a0d3190da84ef6f9cdaf13a11dd13bc
  higherCell d0d89ef5f6f1b1d4b13b6bb2c7192751
  leftCell 1fcd0aeb63942547b516cf8df40bd6a6
  lowerCell b365ab3402e0b802bfae3b031f79a917
  mapField e011b7b413381307ce976d37845fc3d2
  numCell ce69d132984f15c162cb28e115878ea4
  numLine ce69d132984f15c162cb28e115878ea4
  numLoop 6259977f3c94283e5ea8292c918bcb53
  rightCell 98857b461e4106f2a1a231a4d2b3b4d0
  rotateTypeFigure 6259977f3c94283e5ea8292c918bcb53
  typeCellFromField 21e57c95a2c7b52276682d382c51505d
cd917b6f8bcf6b8aaecc693871acbf44
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MyProj.$trModule3
                   MyProj.$trModule1) -}
637140a171b8785eee75ba9876bdb7d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule2) -}
204fe942f1473ca5b92b79589814a20e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MyProj"#) -}
bd66823722c82efecacae7b7af71d506
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule4) -}
99aa6c486c15517abc54f67dbd421cb5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an"#) -}
af5ca0f5ad40f40a033c1835fe0fad0d
  $wcheckFlyCell ::
    Type.Field
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U><S,1*U><L,1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: Type.Field)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#) ->
                 case ww of wild {
                   DEFAULT
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case ww1 of ww3 { GHC.Types.I# ww4 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w (GHC.Prim.+# wild 1#))
                                  ww4 of wild2 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild3 { GHC.Types.I# x ->
                           case x of wild4 {
                             DEFAULT -> GHC.Types.True 0# -> GHC.Types.False } } } } }
                   14#
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }) -}
8b9e3c029e9072e507875d501839a8cc
  $wcompareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (# GHC.Types.Int, Type.CoordCell #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U>, Inline: [2] -}
eb9094434d5f37e86ea7e6749a252f02
  $wcountDeletedLines :: Type.Field -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2] -}
6e3177ce68a0c818f9cd92f6c6c660a2
  $wcreateNewCoord ::
    GHC.Prim.Int# -> GHC.Types.Int -> GHC.Types.Int -> [Type.CoordCell]
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><L,U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 case MyProj.$wnumberNextRotateModel ww of ww3 { DEFAULT ->
                 case GHC.List.$w!!
                        @ (Type.CoordFigures, Type.CoordCell)
                        Type.createRotateModels
                        ww3 of wild { (,) x ds1 ->
                 GHC.Base.map
                   @ (GHC.Types.Int, GHC.Types.Int)
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (\ (coordNewModel :: (GHC.Types.Int, GHC.Types.Int)) ->
                    (case ww1 of wild1 { GHC.Types.I# x1 ->
                     case ds1 of wild2 { (,) x2 ds2 ->
                     case x2 of wild3 { GHC.Types.I# y ->
                     case coordNewModel of wild4 { (,) x3 ds3 ->
                     case x3 of wild5 { GHC.Types.I# y1 ->
                     GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y) y1) } } } } },
                     case ww2 of wild1 { GHC.Types.I# x1 ->
                     case ds1 of wild2 { (,) ds2 y ->
                     case y of wild3 { GHC.Types.I# y1 ->
                     case coordNewModel of wild4 { (,) ds3 y2 ->
                     case y2 of wild5 { GHC.Types.I# y3 ->
                     GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y1) y3) } } } } }))
                   x } }) -}
494e11a825c6074801e645bf8a21fd2f
  $wdeleteOldCellsForRotate ::
    [Type.CoordCell] -> Type.Field -> Type.Field
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
810d7ef06b844609a6cb66661855cc60
  $wfunForSortBy ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><S,U><L,1*U(U)><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww1 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww1 of lwild1 {
                        DEFAULT -> GHC.Types.GT
                        1#
                        -> case ww2 of wild { GHC.Types.I# x ->
                           case ww3 of wild1 { GHC.Types.I# y ->
                           case GHC.Prim.<# x y of lwild2 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.LT } } } }
                   1# -> GHC.Types.LT }) -}
c7fc274cb8fd4e487f24b404a0cb06b4
  $wgameLoop ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Bool
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U><L,U(U)><L,U><L,U><S,1*U><L,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Bool)
                   (ww7 :: GHC.Types.Int)
                   (ww8 :: GHC.Types.Int) ->
                 case ww6 of wild {
                   GHC.Types.False
                   -> case MyProj.haveFlyFigure ww of wild1 {
                        GHC.Types.False
                        -> let {
                             ds :: Type.Field = Type.mapField MyProj.changeLandCellField1 ww
                           } in
                           MyProj.$wnewFigureOnGame
                             (MyProj.deleteLinesFromField ds)
                             ww1
                             ww2
                             (case ww3 of wild2 { GHC.Types.I# x ->
                              case MyProj.$wcountDeletedLines ds 0# of ww9 { DEFAULT ->
                              GHC.Types.I# (GHC.Prim.+# x ww9) } })
                             ww4
                             ww5
                             ww7
                             ww8
                        GHC.Types.True
                        -> Type.GameState
                             (MyProj.shiftFigureOnField ww)
                             ww1
                             ww2
                             ww3
                             ww4
                             ww5
                             GHC.Types.False
                             ww7
                             (case ww8 of wild2 { GHC.Types.I# x ->
                              GHC.Types.I# (GHC.Prim.+# x 1#) }) }
                   GHC.Types.True
                   -> Type.GameState
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        GHC.Types.True
                        ww7
                        ww8 }) -}
2ab8809d5fbf12838dfddea1bde09859
  $wnewFigureOnGame ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 8,
     Strictness: <L,U><L,U><S,1*U><L,U><S,U><L,U><L,U><L,1*U(U)>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Int)
                   (ww7 :: GHC.Types.Int) ->
                 case ww2 of wild {
                   [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                   : x ds1
                   -> case x of ww8 { GHC.Types.I# ww9 ->
                      let {
                        coordNextFigure :: Type.CoordFigures
                        = GHC.List.$w!! @ Type.CoordFigures ww4 ww9
                      } in
                      case MyProj.checkCanAddFigure ww coordNextFigure of wild1 {
                        GHC.Types.False
                        -> Debug.Trace.trace
                             @ Type.GameState
                             MyProj.gameLoop1
                             (Type.GameState
                                ww
                                ww1
                                wild
                                ww3
                                ww4
                                ww5
                                GHC.Types.True
                                ww6
                                (case ww7 of wild2 { GHC.Types.I# x1 ->
                                 GHC.Types.I# (GHC.Prim.+# x1 1#) }))
                        GHC.Types.True
                        -> Type.GameState
                             (MyProj.newFigureOnField
                                ww
                                coordNextFigure
                                (GHC.List.$w!!
                                   @ Graphics.Gloss.Internals.Data.Color.Color
                                   ww5
                                   ww9))
                             ww1
                             ds1
                             ww3
                             ww4
                             ww5
                             GHC.Types.False
                             (case ww9 of wild2 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.-# (GHC.Prim.*# wild2 4#) 3#)
                                0# -> MyProj.changeLandCellField2 })
                             (case ww7 of wild2 { GHC.Types.I# x1 ->
                              GHC.Types.I# (GHC.Prim.+# x1 1#) }) } } }) -}
fbabcfd3913ecc994b175d1e36b3a096
  $wnumberNextRotateModel :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case ww of ds {
                   DEFAULT -> GHC.Prim.+# ds 1#
                   0# -> 0#
                   4# -> 1#
                   8# -> 5#
                   12# -> 9#
                   16# -> 13#
                   20# -> 17#
                   24# -> 21#
                   28# -> 25# }) -}
6c667f97df1f2605ae5a53514cef8fc3
  $wrotateFigure :: Type.Field -> GHC.Prim.Int# -> Type.Field
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: Type.Field) (ww :: GHC.Prim.Int#) ->
                 let {
                   oldCoord :: Type.CoordFigures
                   = MyProj.getCoordsFromCells
                       (Type.findCellCond
                          w
                          MyProj.findCoordFigure1
                          (GHC.Types.[] @ Type.Cell))
                       (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))
                 } in
                 let {
                   ds :: (GHC.Types.Int, GHC.Types.Int)
                   = case GHC.List.$w!!
                            @ (Type.CoordFigures, Type.CoordCell)
                            Type.createRotateModels
                            ww of wild { (,) ds1 y ->
                     y }
                 } in
                 let {
                   newCoord :: [Type.CoordCell]
                   = MyProj.$wcreateNewCoord
                       ww
                       (case GHC.Base.map
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               (Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int)
                               oldCoord of wild {
                          [] -> GHC.List.minimum2
                          : ipv ipv1
                          -> case ipv of ww1 { GHC.Types.I# ww2 ->
                             case GHC.List.$wgo1 ipv1 ww2 of ww3 { DEFAULT ->
                             case ds of wild1 { (,) oldRelMainX oldRelMainY ->
                             case oldRelMainX of wild2 { GHC.Types.I# y ->
                             GHC.Types.I# (GHC.Prim.+# ww3 y) } } } } })
                       (case GHC.Base.map
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               (Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int)
                               oldCoord of wild {
                          [] -> GHC.List.minimum2
                          : ipv ipv1
                          -> case ipv of ww1 { GHC.Types.I# ww2 ->
                             case GHC.List.$wgo1 ipv1 ww2 of ww3 { DEFAULT ->
                             case ds of wild1 { (,) oldRelMainX oldRelMainY ->
                             case oldRelMainY of wild2 { GHC.Types.I# y ->
                             GHC.Types.I# (GHC.Prim.+# ww3 y) } } } } })
                 } in
                 let {
                   fieldDeletedOldCells :: Type.Field
                   = MyProj.$wdeleteOldCellsForRotate oldCoord w
                 } in
                 case MyProj.checkCanRotate fieldDeletedOldCells newCoord of wild {
                   GHC.Types.False -> w
                   GHC.Types.True
                   -> MyProj.setNewCellsdForRotate
                        newCoord
                        (case oldCoord of wild1 {
                           []
                           -> case GHC.List.badHead
                              ret_ty Graphics.Gloss.Internals.Data.Color.Color
                              of {}
                           : x ds1
                           -> case x of wild2 { (,) ds2 y ->
                              case y of ww1 { GHC.Types.I# ww2 ->
                              case ds2 of ww3 { GHC.Types.I# ww4 ->
                              case GHC.List.$w!!
                                     @ Type.Cell
                                     (GHC.List.$w!! @ Type.Line w ww4)
                                     ww2 of wild3 { Type.Cell ds3 ds4 ds5 ds6 ->
                              ds6 } } } } })
                        fieldDeletedOldCells }) -}
d1daa2d9c817c425835f2def4fd32450
  $wrunGameLoop ::
    GHC.Prim.Int#
    -> Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Bool
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 10,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U(U)><L,U><L,U><L,U><L,U><L,U(U)>,
     Inline: [2] -}
faf13b33de84d9f5b00dc8f13b397115
  $wupdate ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Bool
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Bool)
                   (ww7 :: GHC.Types.Int)
                   (ww8 :: GHC.Types.Int) ->
                 Debug.Trace.trace
                   @ (GHC.Types.Int -> Type.GameState -> Type.GameState)
                   (GHC.Show.$fShowInt_$cshow ww8)
                   MyProj.runGameLoop
                   (case ww8 of wild { GHC.Types.I# i ->
                    let {
                      x :: GHC.Prim.Double#
                      = GHC.Prim.+##
                          (GHC.Prim./## (GHC.Prim.int2Double# i) 60.0##)
                          1.0e-4##
                    } in
                    let {
                      n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                    } in
                    case GHC.Prim.<## (GHC.Prim.int2Double# n) x of lwild {
                      DEFAULT -> GHC.Types.I# n
                      1# -> GHC.Types.I# (GHC.Prim.+# n 1#) } })
                   (Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8)) -}
bc4f260b7481027cf65f387315059498
  changeLandCell :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(1*U,U,U,U,U,U,A,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Type.GameState) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 Type.GameState
                   (MyProj.changeLandCellField ds)
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   GHC.Types.False
                   ds7
                   ds8 }) -}
2df8ab02e95c0e2ac2aac1ce417fd7f3
  changeLandCellField :: Type.Field -> Type.Field
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField MyProj.changeLandCellField1 field) -}
6825a11667967758f4fa0ee95835ff85
  changeLandCellField1 :: Type.Cell -> Type.Cell
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(U,U,U(U),U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                 case ds2 of wild1 { GHC.Types.I# ds4 ->
                 case ds4 of ds5 {
                   DEFAULT -> wild
                   1# -> Type.Cell ds ds1 MyProj.changeLandCellField2 ds3 } } }) -}
2922a800fc69ea036734de4abd831bec
  changeLandCellField2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1bf4764c62ddbc7a547d0968e600fc0a
  checkCanAddFigure ::
    Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
83a5cca06100ea5a73cab80ea63b6a86
  checkCanMoveLeft :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveLeft1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
b4b1fdbf102b11a7b9649d59cba9dafe
  checkCanMoveLeft1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.-#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          0#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
8194173daff7b90f001713e810b7e663
  checkCanMoveRight :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveRight1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
9e448c6eea7a143780955aabfb915b95
  checkCanMoveRight1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.+#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          9#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
65f6a159e8874e7cd49ba336529356d3
  checkCanRotate :: Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
705725bbbd815a7d144611970661b204
  checkCompletedLine :: Type.Line -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCompletedLine1
                  `cast`
                (<Type.Line>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
40f9ac628034325b8418343ecf294b17
  checkCompletedLine1 :: Type.Line -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (line :: Type.Line) -> MyProj.checkCompletedLine_go line) -}
f44ce856ea9d7b1d4571149fc30aa762
  checkCompletedLine_go :: [Type.Cell] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b578d2e798d5dd14f90efb329e1926d8
  checkFlyCell :: Type.Field -> Type.Cell -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LS(S)L),1*U(1*U(1*U),1*U(U),1*U(1*U),A)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww3 of ww7 { GHC.Types.I# ww8 ->
                 MyProj.$wcheckFlyCell w ww6 ww2 ww8 } } }) -}
50cd01ae679e71c56fc626a5d5626e7d
  compareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (GHC.Types.Int, Type.CoordCell)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Type.CoordFigures)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [(Type.CoordFigures, Type.CoordCell)]) ->
                 case MyProj.$wcompareFigure w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
80dc3c6a359b2019475bfe931aac6f37
  countDeletedLines :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wcountDeletedLines w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
c38799d9c0e9d35dc03f6697d6a21356
  createCellForMoveLeft :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.+# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveLeft3
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        9#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
09aad780b99117765a977bfb3fa40b3b
  createCellForMoveLeft1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
9ef1dd007f22d55810730485c4f885b3
  createCellForMoveLeft2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
f5a76a1c010407e3b452d147a4752f52
  createCellForMoveLeft3 :: Type.Cell
  {- Strictness: x -}
baf70d744d7bc0233c019ec61a8d1145
  createCellForMoveRight :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.-# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveRight1
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        0#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
61e408f7dd0cd11083f4e1f7369d585e
  createCellForMoveRight1 :: Type.Cell
  {- Strictness: x -}
408d319b697ea54d1f3bbf5c4d91725f
  createCellShiftFigure :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LLL),1*U(U(U),U(U),U(U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of wild {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case GHC.List.$w!!
                             @ Type.Cell
                             (GHC.List.$w!! @ Type.Line w (GHC.Prim.-# wild 1#))
                             ww8 of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 { GHC.Types.I# ds ->
                      case ds of ds7 {
                        DEFAULT -> MyProj.createCellShiftFigure2
                        0# -> Type.Cell (GHC.Types.I# wild) ww7 ww3 ww4
                        1#
                        -> Type.Cell
                             (GHC.Types.I# wild)
                             ww7
                             MyProj.createCellForMoveLeft1
                             ds4
                        2#
                        -> case ww3 of wild3 { GHC.Types.I# ds8 ->
                           case ds8 of ds9 {
                             DEFAULT -> MyProj.createCellShiftFigure1
                             0# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4
                             1#
                             -> Type.Cell
                                  (GHC.Types.I# wild)
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             2# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4 } } } } } }
                   0#
                   -> Type.Cell
                        (GHC.Types.I# 0#)
                        ww2
                        MyProj.createCellForMoveLeft2
                        Graphics.Gloss.Data.Color.white } } }) -}
d2440cc379a9065d6857819b60d0ae72
  createCellShiftFigure1 :: Type.Cell
  {- Strictness: x -}
3373d6a03b48fbb5e29a13076763be5c
  createCellShiftFigure2 :: Type.Cell
  {- Strictness: x -}
ad61b1c616d84e41595975526030a552
  createEnd :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: Type.GameState) -> x) -}
6d78b6abf64723d1bbf8587c3254e568
  createNewCoord ::
    GHC.Types.Int -> Type.CoordCell -> [Type.CoordCell]
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,1*U(U(U),U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Type.CoordCell) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { (,) ww3 ww4 ->
                 MyProj.$wcreateNewCoord ww1 ww3 ww4 } }) -}
dbb27baa6e81185f1386c22a2875b810
  deleteLineWithNumber :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (field :: Type.Field)
                   (numDeletedLine :: GHC.Types.Int) ->
                 Type.mapField
                   (\ (c :: Type.Cell) ->
                    case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                    case ds of wild1 { GHC.Types.I# x ->
                    case numDeletedLine of wild2 { GHC.Types.I# y ->
                    case GHC.Prim.># x y of lwild {
                      DEFAULT
                      -> case x of wild3 {
                           DEFAULT
                           -> let {
                                hc :: Type.Cell
                                = case ds1 of ww2 { GHC.Types.I# ww3 ->
                                  GHC.List.$w!!
                                    @ Type.Cell
                                    (GHC.List.$w!! @ Type.Line field (GHC.Prim.-# wild3 1#))
                                    ww3 }
                              } in
                              Type.Cell wild1 ds1 (Type.getCellType hc) (Type.getCellColor hc)
                           0#
                           -> Type.Cell
                                wild1
                                ds1
                                MyProj.createCellForMoveLeft2
                                Graphics.Gloss.Data.Color.white }
                      1# -> wild } } } })
                   field) -}
446d65a98bbf8d348e53b26406e59ed9
  deleteLines :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U(U),U,U,A,U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 Type.GameState
                   (MyProj.deleteLinesFromField ww1)
                   ww2
                   ww3
                   (case ww4 of wild { GHC.Types.I# x ->
                    case MyProj.$wcountDeletedLines ww1 0# of ww10 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.+# x ww10) } })
                   ww5
                   ww6
                   GHC.Types.False
                   ww8
                   ww9 }) -}
03e72ccf25b8d96f60f496b56a2a1440
  deleteLinesFromField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U> -}
5122d1e032440a88821a1ae696b092eb
  deleteOldCellsForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,A><L,U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [Type.CoordCell])
                   (w1 :: Graphics.Gloss.Internals.Data.Color.Color)
                   (w2 :: Type.Field) ->
                 MyProj.$wdeleteOldCellsForRotate w w2) -}
a2bdecb8e17fe697ed4c512c10df97bb
  findCoordFigure :: Type.Field -> Type.CoordFigures
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 MyProj.getCoordsFromCells
                   (Type.findCellCond
                      field
                      MyProj.findCoordFigure1
                      (GHC.Types.[] @ Type.Cell))
                   (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))) -}
86b18666ea2126efd77bf262cb9ff752
  findCoordFigure1 :: Type.Cell -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(A,A,1*U(1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds1 ds2 ds3 ds4 ->
                 case ds3 of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } } }) -}
ac17f82765c06cfcb67bf68f1b7c15c4
  funForSortBy ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int))
                   (w1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { (,) ww8 ww9 ->
                 MyProj.$wfunForSortBy ww4 ww6 ww8 ww9 } } } }) -}
357f213785084425a79741a63d209984
  gameLoop :: Type.GameState -> Type.GameState
  {- Arity: 1,
     Strictness: <S(LLLLLLSLL),1*U(U,U,U,U(U),U,U,1*U,U,U(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 MyProj.$wgameLoop ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 }) -}
2714efa928a7067334bff003689df877
  gameLoop1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.gameLoop2) -}
9676672856f2618c50207e60dfd42ff1
  gameLoop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("checkEnd"#) -}
3f5fb6300cd9f9215270d755777ed4de
  getCoordsFromCells ::
    [Type.Cell]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
a8750c2164d0194775e5f68a73f187f5
  handleEvent ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState -> Type.GameState
  {- Arity: 2,
     Strictness: <S,1*U><S,1*U(U,U(U,U),U,U,U,U,U,U(U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Graphics.Gloss.Internals.Interface.Event.Event)
                   (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 case w of wild {
                   DEFAULT -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9
                   Graphics.Gloss.Internals.Interface.Event.EventKey ds ds1 ds2 ds3
                   -> case ds of wild1 {
                        DEFAULT -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9
                        Graphics.Gloss.Internals.Interface.Backend.Types.SpecialKey ds4
                        -> case ds4 of wild2 {
                             DEFAULT -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyUp
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.rotateFigure ww1 ww8)
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       ww6
                                       GHC.Types.False
                                       (MyProj.numberNextRotateModel ww8)
                                       ww9
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyLeft
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.moveLeft ww1)
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       ww6
                                       GHC.Types.False
                                       ww8
                                       ww9
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyRight
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.moveRight ww1)
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       ww6
                                       GHC.Types.False
                                       ww8
                                       ww9
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyEnter
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       Type.createField
                                       ww2
                                       (Constans.createListFigures_go ww2)
                                       MyProj.changeLandCellField2
                                       Type.createCoordFigures
                                       Type.createColorFigures
                                       GHC.Types.False
                                       MyProj.handleEvent1
                                       ww9
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState
                                       ww1
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       ww6
                                       ww7
                                       ww8
                                       ww9 } } } } }) -}
7ce9ed21c79999a1629bb876da3ba587
  handleEvent1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 28#) -}
e4c2f1257f397aa2536cfd924439f7eb
  haveFlyFigure :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 let {
                   exit :: GHC.Types.Bool <join 0>
                   = (MyProj.haveFlyFigure_go field)
                       `cast`
                     (Data.Semigroup.Internal.N:Any[0])
                 } in
                 letrec {
                   go :: [Type.Line] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       [] -> exit
                       : y ys
                       -> let {
                            exit1 :: GHC.Types.Bool <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> GHC.Types.Bool
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit1
                                : y1 ys1
                                -> case y1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                                   case ww1 of ww5 { GHC.Types.I# ww6 ->
                                   case ww3 of ww7 { GHC.Types.I# ww8 ->
                                   case ww6 of wild2 {
                                     DEFAULT
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1
                                          1#
                                          -> case ww2 of ww9 { GHC.Types.I# ww10 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!!
                                                       @ Type.Line
                                                       field
                                                       (GHC.Prim.+# wild2 1#))
                                                    ww10 of wild4 { Type.Cell ds2 ds3 ds4 ds5 ->
                                             case ds4 of wild5 { GHC.Types.I# x ->
                                             case x of wild6 {
                                               DEFAULT -> go1 ys1 0# -> GHC.Types.False } } } } }
                                     14#
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1 1# -> GHC.Types.False } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
b478cf662d841f3258ead25805c45268
  haveFlyFigure_go :: [Type.Line] -> Data.Semigroup.Internal.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
35fcc85ef18b61c127a5a6b3a6e0992b
  moveLeft :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveLeft1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveLeft field) field }) -}
3360594b534f4aafdbf5a6d012f281cc
  moveRight :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveRight1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveRight field) field }) -}
43b510fedc8d4cac81ad96c4c8f75e60
  newFigureOnField ::
    Type.Field
    -> Type.CoordFigures
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U> -}
79bc07c1d6f0000aaec200e3ffe60377
  newFigureOnGame :: Type.GameState -> Type.GameState
  {- Arity: 1,
     Strictness: <S(LLSLSLLLL),1*U(U,U,1*U,U,U,U,A,U,1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 MyProj.$wnewFigureOnGame ww1 ww2 ww3 ww4 ww5 ww6 ww8 ww9 }) -}
0af320014ee00296db3ba34ba643275e
  numCompLine :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
a86d715edde92dd4d3fa92939bb7c9d7
  numberNextRotateModel :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wnumberNextRotateModel ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
7f5eab424b7b7fbd6779da8792ac9065
  rotateFigure :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 MyProj.$wrotateFigure w ww1 }) -}
00e7f648a933e0187c2f3ce683de2953
  runGameLoop :: GHC.Types.Int -> Type.GameState -> Type.GameState
  {- Arity: 2,
     Strictness: <S(S),1*U(1*U)><S,1*U(U,U,U,U(U),U,U,U,U,U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Type.GameState) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Type.GameState ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ->
                 MyProj.$wrunGameLoop
                   ww1
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7
                   ww8
                   ww9
                   ww10
                   ww11 } }) -}
d12acbb654edf21db42ab5e75eb38f9c
  setNewCellsdForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
476cd7e5ae164b878396646a211e759a
  shiftFigure :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,A,U,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Type.GameState) ->
                 case ds of wild { Type.GameState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 Type.GameState
                   (MyProj.shiftFigureOnField ds1)
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   GHC.Types.False
                   ds8
                   (case ds9 of wild1 { GHC.Types.I# x ->
                    GHC.Types.I# (GHC.Prim.+# x 1#) }) }) -}
577b8d6703ec15f8acfa7c3ec2f47c59
  shiftFigureOnField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField
                   (\ (c :: Type.Cell) -> MyProj.createCellShiftFigure field c)
                   field) -}
4834b307c017ba34b45ed46f136a22d5
  update :: GHC.Types.Float -> Type.GameState -> Type.GameState
  {- Arity: 2, Strictness: <L,A><S,1*U(U,U,U,U,U,U,U,U,U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 MyProj.$wupdate ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 }) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

