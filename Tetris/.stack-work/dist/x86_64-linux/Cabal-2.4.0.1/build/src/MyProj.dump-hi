
==================== FINAL INTERFACE ====================
2019-03-25 22:09:50.55899341 UTC

interface project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an:MyProj 8063
  interface hash: b26074fcb490e832b452dec61672697b
  ABI hash: 09d65f7cb7b870321e6b00e3360e4a42
  export-list hash: f5a778acc23aa90cef9f187ad018af15
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7a242ffa3d761dff45aed995f1434522
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  MyProj.changeLandCell
  MyProj.changeLandCellField
  MyProj.checkCanAddFigure
  MyProj.checkCanMoveLeft
  MyProj.checkCanMoveRight
  MyProj.checkCanRotate
  MyProj.checkCompletedLine
  MyProj.checkFlyCell
  MyProj.compareFigure
  MyProj.countDeletedLines
  MyProj.createCellForMoveLeft
  MyProj.createCellForMoveRight
  MyProj.createCellShiftFigure
  MyProj.createEnd
  MyProj.createNewCoord
  MyProj.deleteLineWithNumber
  MyProj.deleteLines
  MyProj.deleteLinesFromField
  MyProj.deleteOldCellsForRotate
  MyProj.findCoordFigure
  MyProj.funForSortBy
  MyProj.gameLoop
  MyProj.getCoordsFromCells
  MyProj.handleEvent
  MyProj.haveFlyFigure
  MyProj.moveLeft
  MyProj.moveRight
  MyProj.newFigureOnField
  MyProj.newFigureOnGame
  MyProj.numCompLine
  MyProj.numberNextRotateModel
  MyProj.rotateFigure
  MyProj.setNewCellsdForRotate
  MyProj.shiftFigure
  MyProj.shiftFigureOnField
module dependencies: Constans Draw Type
package dependencies: GLURaw-2.0.0.4 GLUT-2.7.0.14
                      ObjectName-1.1.0.1 OpenGL-3.0.2.2 OpenGLRaw-3.3.2.0
                      StateVar-1.1.1.1 array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bmp-1.2.6.3 bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      fixed-0.2.1.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 gloss-1.13.0.1
                      gloss-rendering-1.13.0.2 half-0.3 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 random-1.1 stm-2.5.0.0 template-haskell-2.14.0.0
                      text-1.2.3.1 time-1.8.0.2
orphans: stm-2.5.0.0:Control.Monad.STM text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic text-1.2.3.1:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type half-0.3:Numeric.Half
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.List ce2c69da408fdc014383cede9e1f9adf
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:Debug.Trace 6e89d30f3850c77c707392fc46e9b589
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  gloss-1.13.0.1:Graphics.Gloss dc3d422d35cd32353ee5470deb98e8ac
import  -/  gloss-1.13.0.1:Graphics.Gloss.Interface.Pure.Game 3b871ad7b6d70d672603a275ef8ba1e4
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Backend.Types 9cdc96871bc000bfa29ef8cfad3eb219
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Event 70b3da3875a2c6427df4272fec7eb5e1
import  -/  gloss-rendering-1.13.0.2:Graphics.Gloss.Internals.Data.Color 2716426e7777628bb37f6a888abf7b9e
import  -/  Constans 2bd7c9d69811db52caca3e7a07dbac3a
  exports: 4e851395688f4e2271ad07b9b5734963
  colorBoard a46ee52867c7f2352348479a0f097919
import  -/  Draw 1a776618c5ef429718205b575876f70e
  exports: 551067e2732157ecbd258059c1ba69cc
import  -/  Type df59caa494a616a7b0857b7bb08caaa9
  exports: ce00df076bf5945b2ec222b3a5119386
  Cell a490fb91284b41c392b2e9ae69e56c0f
  Cell ce69d132984f15c162cb28e115878ea4
  CoordCell a84a815ac9d0a4e801bd442bfa023e94
  CoordFigures b3b9710d1bc9d5841b96879fe6ccdd74
  Field cff2286d27e6392df8d5af5cd3f4b99a
  GameState 4db1b57dd81e4bc1cc718d685ed5c8b4
  GameState 3c2a97b0bb2bff3c82c2e04143c99934
  Line bec16fc1c01d7327740e42f85f13dafe
  cellColor ce69d132984f15c162cb28e115878ea4
  cellType ce69d132984f15c162cb28e115878ea4
  changeCellInField 26217e12acaf2e7546740dd30e9aeca6
  colorTetr 3c2a97b0bb2bff3c82c2e04143c99934
  coordTetr 3c2a97b0bb2bff3c82c2e04143c99934
  createRotateModels 034ff93e7aecb5bc09b8c7a0cd17bc9c
  endGame 3c2a97b0bb2bff3c82c2e04143c99934
  findCellCond 23c0104d27cbb4885b4db356b48a4902
  funFieldAll f3348f54733fff744c14c483dc51410e
  funFieldAny e2fc49ae8e6e6604234795ccc0087a1c
  funLineAll e24fd0894b0db4c0f3ced2f703c0dbb6
  gameField 3c2a97b0bb2bff3c82c2e04143c99934
  gameFigures 3c2a97b0bb2bff3c82c2e04143c99934
  gameRandomGen 3c2a97b0bb2bff3c82c2e04143c99934
  gameResult 3c2a97b0bb2bff3c82c2e04143c99934
  getCell e0b0d74dc81858d2413e5fb147c7c3a8
  getCellColor cbf98000775ec3539180fa3ef9520b83
  getCellType 8a0d3190da84ef6f9cdaf13a11dd13bc
  higherCell d0d89ef5f6f1b1d4b13b6bb2c7192751
  leftCell 1fcd0aeb63942547b516cf8df40bd6a6
  lowerCell b365ab3402e0b802bfae3b031f79a917
  mapField e011b7b413381307ce976d37845fc3d2
  numCell ce69d132984f15c162cb28e115878ea4
  numLine ce69d132984f15c162cb28e115878ea4
  rightCell 98857b461e4106f2a1a231a4d2b3b4d0
  rotateTypeFigure 3c2a97b0bb2bff3c82c2e04143c99934
  typeCellFromField 21e57c95a2c7b52276682d382c51505d
import  -/  random-1.1:System.Random 8c06dce30a9b8b4f2b7c15fb3f418e08
cd917b6f8bcf6b8aaecc693871acbf44
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MyProj.$trModule3
                   MyProj.$trModule1) -}
637140a171b8785eee75ba9876bdb7d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule2) -}
204fe942f1473ca5b92b79589814a20e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MyProj"#) -}
bd66823722c82efecacae7b7af71d506
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule4) -}
99aa6c486c15517abc54f67dbd421cb5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an"#) -}
af5ca0f5ad40f40a033c1835fe0fad0d
  $wcheckFlyCell ::
    Type.Field
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U><S,1*U><L,1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: Type.Field)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#) ->
                 case ww of wild {
                   DEFAULT
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True
                        1#
                        -> case ww1 of ww3 { GHC.Types.I# ww4 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w (GHC.Prim.+# wild 1#))
                                  ww4 of wild2 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild3 { GHC.Types.I# x ->
                           case x of wild4 {
                             DEFAULT -> GHC.Types.True 0# -> GHC.Types.False } } } } }
                   14#
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True 1# -> GHC.Types.False } }) -}
eb9094434d5f37e86ea7e6749a252f02
  $wcountDeletedLines :: Type.Field -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2] -}
1c53ac5387dd5d1e66350f2bcf3df6d8
  $wcreateNewCoord ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> [Type.CoordCell]
  {- Arity: 3, Strictness: <L,U(U)><L,U(U)><L,U(U)>, Inline: [2] -}
494e11a825c6074801e645bf8a21fd2f
  $wdeleteOldCellsForRotate ::
    [Type.CoordCell] -> Type.Field -> Type.Field
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
810d7ef06b844609a6cb66661855cc60
  $wfunForSortBy ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><S,U><L,1*U(U)><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww1 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww1 of lwild1 {
                        DEFAULT -> GHC.Types.GT
                        1#
                        -> case ww2 of wild { GHC.Types.I# x ->
                           case ww3 of wild1 { GHC.Types.I# y ->
                           case GHC.Prim.<# x y of lwild2 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.LT } } } }
                   1# -> GHC.Types.LT }) -}
8025518234381fdc4c6e0c3b16ba9f0c
  $wgameLoop ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Bool
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 8,
     Strictness: <L,U><L,U><L,U><L,U(U)><L,U><L,U><S,1*U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Bool)
                   (ww7 :: GHC.Types.Int) ->
                 case ww6 of wild {
                   GHC.Types.False
                   -> case MyProj.haveFlyFigure ww of wild1 {
                        GHC.Types.False
                        -> let {
                             ds :: Type.Field = Type.mapField MyProj.changeLandCellField1 ww
                           } in
                           MyProj.$wnewFigureOnGame
                             (MyProj.deleteLinesFromField ds)
                             ww1
                             ww2
                             (case ww3 of wild2 { GHC.Types.I# x ->
                              case MyProj.$wcountDeletedLines ds 0# of ww8 { DEFAULT ->
                              GHC.Types.I# (GHC.Prim.+# x ww8) } })
                             ww4
                             ww5
                             ww7
                        GHC.Types.True
                        -> Type.GameState
                             (MyProj.shiftFigureOnField ww)
                             ww1
                             ww2
                             ww3
                             ww4
                             ww5
                             GHC.Types.False
                             ww7 }
                   GHC.Types.True
                   -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 GHC.Types.True ww7 }) -}
fbfc1dc203a70aff2957237ec947c522
  $whandleEvent ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Bool
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 9,
     Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U)>,
     Inline: [2],
     Unfolding: (\ (w :: Graphics.Gloss.Internals.Interface.Event.Event)
                   (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Bool)
                   (ww7 :: GHC.Types.Int) ->
                 case w of wild {
                   DEFAULT -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7
                   Graphics.Gloss.Internals.Interface.Event.EventKey ds ds1 ds2 ds3
                   -> case ds of wild1 {
                        DEFAULT -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7
                        Graphics.Gloss.Internals.Interface.Backend.Types.SpecialKey ds4
                        -> case ds4 of wild2 {
                             DEFAULT -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyUp
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Debug.Trace.trace
                                       @ (Type.Field
                                          -> System.Random.StdGen
                                          -> [Type.NumberFigure]
                                          -> GHC.Types.Int
                                          -> [Type.CoordFigures]
                                          -> [Graphics.Gloss.Internals.Data.Color.Color]
                                          -> GHC.Types.Bool
                                          -> GHC.Types.Int
                                          -> Type.GameState)
                                       (GHC.Show.$fShowInt_$cshow ww7)
                                       Type.GameState
                                       (MyProj.rotateFigure ww ww7)
                                       ww1
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       GHC.Types.False
                                       (MyProj.numberNextRotateModel ww7)
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyLeft
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.moveLeft ww)
                                       ww1
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       GHC.Types.False
                                       ww7
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyRight
                             -> case ds1 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> Type.GameState
                                       (MyProj.moveRight ww)
                                       ww1
                                       ww2
                                       ww3
                                       ww4
                                       ww5
                                       GHC.Types.False
                                       ww7
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 } } } }) -}
a5595638559a48141087649fe53a98f7
  $wnewFigureOnGame ::
    Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> GHC.Types.Int
    -> Type.GameState
  {- Arity: 7, Strictness: <L,U><L,U><S,1*U><L,U><S,U><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ (ww :: Type.Field)
                   (ww1 :: System.Random.StdGen)
                   (ww2 :: [Type.NumberFigure])
                   (ww3 :: GHC.Types.Int)
                   (ww4 :: [Type.CoordFigures])
                   (ww5 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww6 :: GHC.Types.Int) ->
                 case ww2 of wild {
                   [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                   : x ds1
                   -> case x of ww7 { GHC.Types.I# ww8 ->
                      let {
                        coordNextFigure :: Type.CoordFigures
                        = GHC.List.$w!! @ Type.CoordFigures ww4 ww8
                      } in
                      case MyProj.checkCanAddFigure ww coordNextFigure of wild1 {
                        GHC.Types.False
                        -> Debug.Trace.trace
                             @ Type.GameState
                             MyProj.gameLoop1
                             (Type.GameState ww ww1 wild ww3 ww4 ww5 GHC.Types.True ww6)
                        GHC.Types.True
                        -> Type.GameState
                             (MyProj.newFigureOnField
                                ww
                                coordNextFigure
                                (GHC.List.$w!!
                                   @ Graphics.Gloss.Internals.Data.Color.Color
                                   ww5
                                   ww8))
                             ww1
                             ds1
                             ww3
                             ww4
                             ww5
                             GHC.Types.False
                             (GHC.Types.I# (GHC.Prim.*# ww8 4#)) } } }) -}
ad558e06abeb6c554cb078fe3e3d22bf
  $wnumberNextRotateModel :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case ww of ds {
                   DEFAULT -> GHC.Prim.+# ds 1#
                   3# -> 0#
                   7# -> 4#
                   11# -> 8#
                   15# -> 12#
                   19# -> 16#
                   23# -> 20#
                   27# -> 24# }) -}
522be06572acee07e913197657cc124c
  changeLandCell :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U,U,U,U,U,U,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Type.GameState) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ->
                 Type.GameState
                   (MyProj.changeLandCellField ds)
                   ds1
                   ds2
                   ds3
                   ds4
                   ds5
                   GHC.Types.False
                   ds7 }) -}
2df8ab02e95c0e2ac2aac1ce417fd7f3
  changeLandCellField :: Type.Field -> Type.Field
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField MyProj.changeLandCellField1 field) -}
6825a11667967758f4fa0ee95835ff85
  changeLandCellField1 :: Type.Cell -> Type.Cell
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(U,U,U(U),U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                 case ds2 of wild1 { GHC.Types.I# ds4 ->
                 case ds4 of ds5 {
                   DEFAULT -> wild
                   1# -> Type.Cell ds ds1 MyProj.changeLandCellField2 ds3 } } }) -}
2922a800fc69ea036734de4abd831bec
  changeLandCellField2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1bf4764c62ddbc7a547d0968e600fc0a
  checkCanAddFigure ::
    Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
83a5cca06100ea5a73cab80ea63b6a86
  checkCanMoveLeft :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveLeft1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
b4b1fdbf102b11a7b9649d59cba9dafe
  checkCanMoveLeft1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.-#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          0#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
8194173daff7b90f001713e810b7e663
  checkCanMoveRight :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveRight1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
9e448c6eea7a143780955aabfb915b95
  checkCanMoveRight1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 { GHC.Types.I# x ->
                                   case x of wild4 {
                                     DEFAULT -> go1 ys1
                                     1#
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild5 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.+#
                                                       wild5
                                                       1#) of wild6 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild7 { GHC.Types.I# x1 ->
                                             case x1 of wild8 {
                                               DEFAULT -> go1 ys1
                                               0#
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0])) } } } }
                                          9#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
65f6a159e8874e7cd49ba336529356d3
  checkCanRotate :: Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
705725bbbd815a7d144611970661b204
  checkCompletedLine :: Type.Line -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCompletedLine1
                  `cast`
                (<Type.Line>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
40f9ac628034325b8418343ecf294b17
  checkCompletedLine1 :: Type.Line -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (line :: Type.Line) -> MyProj.checkCompletedLine_go line) -}
f44ce856ea9d7b1d4571149fc30aa762
  checkCompletedLine_go :: [Type.Cell] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b578d2e798d5dd14f90efb329e1926d8
  checkFlyCell :: Type.Field -> Type.Cell -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LS(S)L),1*U(1*U(1*U),1*U(U),1*U(1*U),A)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww3 of ww7 { GHC.Types.I# ww8 ->
                 MyProj.$wcheckFlyCell w ww6 ww2 ww8 } } }) -}
813f47b6da08081013616c9ce291beca
  compareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (GHC.Types.Int, Type.CoordCell)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U> -}
80dc3c6a359b2019475bfe931aac6f37
  countDeletedLines :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wcountDeletedLines w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
c38799d9c0e9d35dc03f6697d6a21356
  createCellForMoveLeft :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.+# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveLeft3
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        9#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
09aad780b99117765a977bfb3fa40b3b
  createCellForMoveLeft1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
9ef1dd007f22d55810730485c4f885b3
  createCellForMoveLeft2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 2#) -}
f5a76a1c010407e3b452d147a4752f52
  createCellForMoveLeft3 :: Type.Cell
  {- Strictness: x -}
baf70d744d7bc0233c019ec61a8d1145
  createCellForMoveRight :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(LLS(S)L),1*U(U(U),U(U),1*U(1*U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of ds {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case ww8 of wild {
                        DEFAULT
                        -> case ww1 of ww9 { GHC.Types.I# ww10 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww10)
                                  (GHC.Prim.-# wild 1#) of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                           case ds3 of wild2 { GHC.Types.I# ds7 ->
                           case ds7 of ds8 {
                             DEFAULT -> MyProj.createCellForMoveRight1
                             0#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             1# -> Type.Cell ww9 ww7 MyProj.createCellForMoveLeft1 ds4
                             2#
                             -> Type.Cell
                                  ww9
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white } } } }
                        0#
                        -> Type.Cell
                             ww1
                             ww7
                             MyProj.createCellForMoveLeft2
                             Graphics.Gloss.Data.Color.white } }
                   0# -> Type.Cell ww1 ww2 (GHC.Types.I# 0#) ww4 } } }) -}
61e408f7dd0cd11083f4e1f7369d585e
  createCellForMoveRight1 :: Type.Cell
  {- Strictness: x -}
408d319b697ea54d1f3bbf5c4d91725f
  createCellShiftFigure :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LLL),1*U(U(U),U(U),U(U),U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of wild {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case GHC.List.$w!!
                             @ Type.Cell
                             (GHC.List.$w!! @ Type.Line w (GHC.Prim.-# wild 1#))
                             ww8 of wild1 { Type.Cell ds1 ds2 ds3 ds4 ->
                      case ds3 of wild2 { GHC.Types.I# ds ->
                      case ds of ds7 {
                        DEFAULT -> MyProj.createCellShiftFigure2
                        0# -> Type.Cell (GHC.Types.I# wild) ww7 ww3 ww4
                        1#
                        -> Type.Cell
                             (GHC.Types.I# wild)
                             ww7
                             MyProj.createCellForMoveLeft1
                             ds4
                        2#
                        -> case ww3 of wild3 { GHC.Types.I# ds8 ->
                           case ds8 of ds9 {
                             DEFAULT -> MyProj.createCellShiftFigure1
                             0# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4
                             1#
                             -> Type.Cell
                                  (GHC.Types.I# wild)
                                  ww7
                                  MyProj.createCellForMoveLeft2
                                  Graphics.Gloss.Data.Color.white
                             2# -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4 } } } } } }
                   0#
                   -> Type.Cell
                        (GHC.Types.I# 0#)
                        ww2
                        MyProj.createCellForMoveLeft2
                        Graphics.Gloss.Data.Color.white } } }) -}
d2440cc379a9065d6857819b60d0ae72
  createCellShiftFigure1 :: Type.Cell
  {- Strictness: x -}
3373d6a03b48fbb5e29a13076763be5c
  createCellShiftFigure2 :: Type.Cell
  {- Strictness: x -}
ac1e133c3d966b0cb61e1d441aa5d4e9
  createEnd :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: Type.GameState) -> x) -}
7427e5fbc95947f8e9874ea5b3571586
  createNewCoord ::
    GHC.Types.Int -> Type.CoordCell -> [Type.CoordCell]
  {- Arity: 2, Strictness: <L,U(U)><S,1*U(U(U),U(U))>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Type.CoordCell) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 MyProj.$wcreateNewCoord w ww1 ww2 }) -}
dbb27baa6e81185f1386c22a2875b810
  deleteLineWithNumber :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (field :: Type.Field)
                   (numDeletedLine :: GHC.Types.Int) ->
                 Type.mapField
                   (\ (c :: Type.Cell) ->
                    case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                    case ds of wild1 { GHC.Types.I# x ->
                    case numDeletedLine of wild2 { GHC.Types.I# y ->
                    case GHC.Prim.># x y of lwild {
                      DEFAULT
                      -> case x of wild3 {
                           DEFAULT
                           -> let {
                                hc :: Type.Cell
                                = case ds1 of ww2 { GHC.Types.I# ww3 ->
                                  GHC.List.$w!!
                                    @ Type.Cell
                                    (GHC.List.$w!! @ Type.Line field (GHC.Prim.-# wild3 1#))
                                    ww3 }
                              } in
                              Type.Cell wild1 ds1 (Type.getCellType hc) (Type.getCellColor hc)
                           0#
                           -> Type.Cell
                                wild1
                                ds1
                                MyProj.createCellForMoveLeft2
                                Graphics.Gloss.Data.Color.white }
                      1# -> wild } } } })
                   field) -}
ceea3b24d285ce3520d53125324911d8
  deleteLines :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,1*U(U),U,U,A,U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 Type.GameState
                   (MyProj.deleteLinesFromField ww1)
                   ww2
                   ww3
                   (case ww4 of wild { GHC.Types.I# x ->
                    case MyProj.$wcountDeletedLines ww1 0# of ww9 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.+# x ww9) } })
                   ww5
                   ww6
                   GHC.Types.False
                   ww8 }) -}
03e72ccf25b8d96f60f496b56a2a1440
  deleteLinesFromField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U> -}
5122d1e032440a88821a1ae696b092eb
  deleteOldCellsForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,A><L,U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [Type.CoordCell])
                   (w1 :: Graphics.Gloss.Internals.Data.Color.Color)
                   (w2 :: Type.Field) ->
                 MyProj.$wdeleteOldCellsForRotate w w2) -}
a2bdecb8e17fe697ed4c512c10df97bb
  findCoordFigure :: Type.Field -> Type.CoordFigures
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 MyProj.getCoordsFromCells
                   (Type.findCellCond
                      field
                      MyProj.findCoordFigure1
                      (GHC.Types.[] @ Type.Cell))
                   (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))) -}
86b18666ea2126efd77bf262cb9ff752
  findCoordFigure1 :: Type.Cell -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(S)L),1*U(A,A,1*U(1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds1 ds2 ds3 ds4 ->
                 case ds3 of wild1 { GHC.Types.I# x ->
                 case x of wild2 {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Types.True } } }) -}
ac17f82765c06cfcb67bf68f1b7c15c4
  funForSortBy ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int))
                   (w1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { (,) ww8 ww9 ->
                 MyProj.$wfunForSortBy ww4 ww6 ww8 ww9 } } } }) -}
00c72ea3e6f47fc1c4334ba7bb7534d3
  gameLoop :: GHC.Types.Float -> Type.GameState -> Type.GameState
  {- Arity: 2,
     Strictness: <L,A><S(LLLLLLSL),1*U(U,U,U,U(U),U,U,1*U,U)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 MyProj.$wgameLoop ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 }) -}
2714efa928a7067334bff003689df877
  gameLoop1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.gameLoop2) -}
9676672856f2618c50207e60dfd42ff1
  gameLoop2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("checkEnd"#) -}
3f5fb6300cd9f9215270d755777ed4de
  getCoordsFromCells ::
    [Type.Cell]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
bd20d1f993c9e2d0cfcc89c1a9b76a81
  handleEvent ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState -> Type.GameState
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,U,U,U,U,U,U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Graphics.Gloss.Internals.Interface.Event.Event)
                   (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 MyProj.$whandleEvent w ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 }) -}
e4c2f1257f397aa2536cfd924439f7eb
  haveFlyFigure :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 let {
                   exit :: GHC.Types.Bool <join 0>
                   = (MyProj.haveFlyFigure_go field)
                       `cast`
                     (Data.Semigroup.Internal.N:Any[0])
                 } in
                 letrec {
                   go :: [Type.Line] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       [] -> exit
                       : y ys
                       -> let {
                            exit1 :: GHC.Types.Bool <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> GHC.Types.Bool
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit1
                                : y1 ys1
                                -> case y1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                                   case ww1 of ww5 { GHC.Types.I# ww6 ->
                                   case ww3 of ww7 { GHC.Types.I# ww8 ->
                                   case ww6 of wild2 {
                                     DEFAULT
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1
                                          1#
                                          -> case ww2 of ww9 { GHC.Types.I# ww10 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!!
                                                       @ Type.Line
                                                       field
                                                       (GHC.Prim.+# wild2 1#))
                                                    ww10 of wild4 { Type.Cell ds2 ds3 ds4 ds5 ->
                                             case ds4 of wild5 { GHC.Types.I# x ->
                                             case x of wild6 {
                                               DEFAULT -> go1 ys1 0# -> GHC.Types.False } } } } }
                                     14#
                                     -> case ww8 of wild3 {
                                          DEFAULT -> go1 ys1 1# -> GHC.Types.False } } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
b478cf662d841f3258ead25805c45268
  haveFlyFigure_go :: [Type.Line] -> Data.Semigroup.Internal.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
35fcc85ef18b61c127a5a6b3a6e0992b
  moveLeft :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveLeft1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveLeft field) field }) -}
3360594b534f4aafdbf5a6d012f281cc
  moveRight :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveRight1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveRight field) field }) -}
43b510fedc8d4cac81ad96c4c8f75e60
  newFigureOnField ::
    Type.Field
    -> Type.CoordFigures
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U> -}
aabeaa00c2d3cb0c5b3eec7032e64de5
  newFigureOnGame :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S(LLSLSLLL),1*U(U,U,1*U,U,U,U,A,U)>,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ->
                 MyProj.$wnewFigureOnGame ww1 ww2 ww3 ww4 ww5 ww6 ww8 }) -}
0af320014ee00296db3ba34ba643275e
  numCompLine :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
38eb687d961a2af0e68dc1f987fc89e9
  numberNextRotateModel :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wnumberNextRotateModel ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
d84744ce34ea503ac0f2453edc3d20e4
  rotateFigure :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <L,U><L,U(U)> -}
d12acbb654edf21db42ab5e75eb38f9c
  setNewCellsdForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
6077a8b565c98f68b10d3707d80036e8
  shiftFigure :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Type.GameState) ->
                 case ds of wild { Type.GameState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ->
                 Type.GameState
                   (MyProj.shiftFigureOnField ds1)
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   GHC.Types.False
                   ds8 }) -}
577b8d6703ec15f8acfa7c3ec2f47c59
  shiftFigureOnField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField
                   (\ (c :: Type.Cell) -> MyProj.createCellShiftFigure field c)
                   field) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

