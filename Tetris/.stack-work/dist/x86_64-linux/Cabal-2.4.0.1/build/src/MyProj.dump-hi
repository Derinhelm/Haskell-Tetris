
==================== FINAL INTERFACE ====================
2019-04-02 15:07:46.996993058 UTC

interface project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an:MyProj 8063
  interface hash: 7fc190a4fba75fa009af39e2b5795b25
  ABI hash: eab7ccd2c1ce16773c6bfa3e8eedeffe
  export-list hash: d91d4f52041b71e8765c2598e8fcce96
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 7a242ffa3d761dff45aed995f1434522
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  MyProj.changeLandCell
  MyProj.changeLandCellField
  MyProj.checkCanAddFigure
  MyProj.checkCanMoveLeft
  MyProj.checkCanMoveRight
  MyProj.checkCanRotate
  MyProj.checkCompletedLine
  MyProj.checkFlyCell
  MyProj.compareFigure
  MyProj.countDeletedLines
  MyProj.createCellForMoveLeft
  MyProj.createCellForMoveRight
  MyProj.createCellShiftFigure
  MyProj.createEnd
  MyProj.createNewCoord
  MyProj.deleteLineWithNumber
  MyProj.deleteLines
  MyProj.deleteLinesFromField
  MyProj.deleteOldCellsForRotate
  MyProj.findCoordFigure
  MyProj.funForSortBy
  MyProj.gameLoop
  MyProj.getCoordsFromCells
  MyProj.handleEvent
  MyProj.haveFlyFigure
  MyProj.moveLeft
  MyProj.moveRight
  MyProj.newFigureOnField
  MyProj.newFigureOnGame
  MyProj.numCompLine
  MyProj.numberNextRotateModel
  MyProj.rotateFigure
  MyProj.runGameLoop
  MyProj.setNewCellsdForRotate
  MyProj.shiftFigure
  MyProj.shiftFigureOnField
  MyProj.update
module dependencies: Constans Draw Type
package dependencies: GLURaw-2.0.0.4 GLUT-2.7.0.14
                      ObjectName-1.1.0.1 OpenGL-3.0.2.2 OpenGLRaw-3.3.2.0
                      StateVar-1.1.1.1 array-0.5.3.0 base-4.12.0.0 binary-0.8.6.0
                      bmp-1.2.6.3 bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      fixed-0.2.1.1 ghc-boot-th-8.6.3 ghc-prim-0.5.3 gloss-1.13.0.1
                      gloss-rendering-1.13.0.2 half-0.3 integer-gmp-1.0.2.0
                      pretty-1.1.3.6 random-1.1 stm-2.5.0.0 template-haskell-2.14.0.0
                      text-1.2.3.1 time-1.8.0.2
orphans: stm-2.5.0.0:Control.Monad.STM text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic text-1.2.3.1:Data.Text.Show
         bytestring-0.10.8.2:Data.ByteString.Builder
         time-1.8.0.2:Data.Time.Format.Parse
         time-1.8.0.2:Data.Time.LocalTime.Internal.ZonedTime
         time-1.8.0.2:Data.Time.LocalTime.Internal.LocalTime
         time-1.8.0.2:Data.Time.Calendar.Gregorian base-4.12.0.0:GHC.Float
         base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         ghc-boot-th-8.6.3:GHC.ForeignSrcLang.Type
                         ghc-boot-th-8.6.3:GHC.LanguageExtensions.Type half-0.3:Numeric.Half
                         pretty-1.1.3.6:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.6:Text.PrettyPrint.HughesPJ
                         template-haskell-2.14.0.0:Language.Haskell.TH.Syntax
                         text-1.2.3.1:Data.Text
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.List ce2c69da408fdc014383cede9e1f9adf
import  -/  base-4.12.0.0:Data.Maybe 1e8e1362415df45376dffd98f8a47766
import  -/  base-4.12.0.0:Data.Tuple c92a835d04b6c075a7031d4e28e53c71
import  -/  base-4.12.0.0:Debug.Trace 6e89d30f3850c77c707392fc46e9b589
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.List 734a72beb76d276fb4a0ba2689a5711f
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:GHC.Show 4e438f26d903388cc6c2c5d64ed01b98
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  base-4.12.0.0:System.IO 88c2b1c4079c52d62ed362d4eb9a5302
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  ghc-prim-0.5.3:GHC.Types 57064c9f957b09bc2e360061ad5cae0b
import  -/  gloss-1.13.0.1:Graphics.Gloss dc3d422d35cd32353ee5470deb98e8ac
import  -/  gloss-1.13.0.1:Graphics.Gloss.Interface.Pure.Game 3b871ad7b6d70d672603a275ef8ba1e4
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Backend.Types 9cdc96871bc000bfa29ef8cfad3eb219
import  -/  gloss-1.13.0.1:Graphics.Gloss.Internals.Interface.Event 70b3da3875a2c6427df4272fec7eb5e1
import  -/  gloss-rendering-1.13.0.2:Graphics.Gloss.Internals.Data.Color 2716426e7777628bb37f6a888abf7b9e
import  -/  Constans e9afc600b2346cdc8aaa40b884867ea7
  exports: 9c3bf02aef4de5ad20ea7235691d8b63
  colorBoard a46ee52867c7f2352348479a0f097919
import  -/  Draw b199c52ebe6b9372c4564609004d2075
  exports: a55f534379c28c5818bca346145d53b4
import  -/  Type 474f023ed593e4ad46fcc65960cc9981
  exports: 7d4f048f3601777da3a5c061706431a6
  Cell 3116c53c44e6ed5a144124e614391e89
  Cell e228461bbcff362ca52d6588cd0a3991
  CoordCell a84a815ac9d0a4e801bd442bfa023e94
  CoordFigures b3b9710d1bc9d5841b96879fe6ccdd74
  Emp 28fe712a6cc644885dff1276f95cbb67
  Field e435f101da1e2a00b8af045065ea29d8
  FirstEnd 745aeebe38022afc381ab4e2e40ffff9
  Fly f81948349746e197a9bddab5da9a7d4c
  Game 856ae392e822dc746d47468322ff5ccd
  GameState b023aa7734a7b3bee91283ec87b16945
  GameState af8412db864a9629e18c4a0ad20c86a2
  Land d1f9585ce594eaf87d2ac0d6153453c9
  Line 5902b1243452c2df1880aebbf12007e4
  OldEnd 63cc35f442f926e5b1d4ec4fbcaccbb2
  cellColor e228461bbcff362ca52d6588cd0a3991
  cellType e228461bbcff362ca52d6588cd0a3991
  changeCellInField 7cda88d99de21201efa8ad18ca7a4964
  colorTetr af8412db864a9629e18c4a0ad20c86a2
  coordTetr af8412db864a9629e18c4a0ad20c86a2
  createField 40bbd413d1fe3a899500b5646daf4743
  createRotateModels 9e4960b9494fd54f1e1384f9d433e95f
  endGame af8412db864a9629e18c4a0ad20c86a2
  findCellCond 5fed188e502ac81c904d678614e798b2
  funFieldAll 444ef147b659e336964d8643bd8950fa
  funFieldAny 14ac2ab090fc403cf2c8a5edf331203c
  funLineAll 768693d9edc4bc0edd9dd21d08cccba5
  gameField af8412db864a9629e18c4a0ad20c86a2
  gameFigures af8412db864a9629e18c4a0ad20c86a2
  gameRandomGen af8412db864a9629e18c4a0ad20c86a2
  gameResult af8412db864a9629e18c4a0ad20c86a2
  getCell 888cebdf6d14d2cb61fba13ade7ce773
  getCellColor 4853f46cc57fca24829c05f0daff7004
  getCellType 513bb217d37caf67403906f25c15cafa
  higherCell 19a081c76e8b709a9826e11bb3e8c423
  leftCell 4625d9e60390b3987f08569091ebd455
  lowerCell 8b33e6207a6178edaeb62c2c3785e04d
  mapField b0beb14a7d6891908f91f661d29b07f3
  numCell e228461bbcff362ca52d6588cd0a3991
  numLine e228461bbcff362ca52d6588cd0a3991
  numLoop af8412db864a9629e18c4a0ad20c86a2
  rightCell f0be21e80f07b1031e5aaa1b7e2a33ac
  rotateTypeFigure af8412db864a9629e18c4a0ad20c86a2
  typeCellFromField 5547fa9b1fe6ed5969a9c8c31b7d437a
  userName af8412db864a9629e18c4a0ad20c86a2
cd917b6f8bcf6b8aaecc693871acbf44
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MyProj.$trModule3
                   MyProj.$trModule1) -}
637140a171b8785eee75ba9876bdb7d6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule2) -}
204fe942f1473ca5b92b79589814a20e
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MyProj"#) -}
bd66823722c82efecacae7b7af71d506
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MyProj.$trModule4) -}
99aa6c486c15517abc54f67dbd421cb5
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("project-template-0.0.0.0-HkCShUnfJdZ4nPO3MEi7an"#) -}
660a3b0599752bf656d99ed13c691c25
  $wcheckFlyCell ::
    Type.Field
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> Type.TypeCell
    -> GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U><S,1*U><L,1*U(U)><S,1*U>,
     Inline: [2],
     Unfolding: (\ (w :: Type.Field)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: Type.TypeCell) ->
                 case ww of wild {
                   DEFAULT
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True
                        Type.Fly
                        -> case ww1 of ww3 { GHC.Types.I# ww4 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w (GHC.Prim.+# wild 1#))
                                  ww4 of wild2 { Type.Cell ds ds1 ds2 ds3 ->
                           case ds2 of wild3 {
                             Type.Land -> GHC.Types.False
                             Type.Fly -> GHC.Types.True
                             Type.Emp -> GHC.Types.True } } } }
                   14#
                   -> case ww2 of wild1 {
                        DEFAULT -> GHC.Types.True Type.Fly -> GHC.Types.False } }) -}
8b9e3c029e9072e507875d501839a8cc
  $wcompareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (# GHC.Types.Int, Type.CoordCell #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U>, Inline: [2] -}
535582f242a154846a69da82620b9e4d
  $wcountDeletedLines :: Type.Field -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,U>, Inline: [2] -}
415b8fd304777c97a775fe48a1dfbf79
  $wcreateNewCoord ::
    GHC.Prim.Int# -> GHC.Types.Int -> GHC.Types.Int -> [Type.CoordCell]
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><L,U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int) ->
                 case MyProj.$wnumberNextRotateModel ww of ww3 { DEFAULT ->
                 case GHC.List.$w!!
                        @ (Type.CoordFigures, Type.CoordCell)
                        Type.createRotateModels
                        ww3 of wild { (,) x ds1 ->
                 GHC.Base.map
                   @ (GHC.Types.Int, GHC.Types.Int)
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (\ (coordNewModel :: (GHC.Types.Int, GHC.Types.Int)) ->
                    (case ww1 of wild1 { GHC.Types.I# x1 ->
                     case ds1 of wild2 { (,) x2 ds2 ->
                     case x2 of wild3 { GHC.Types.I# y ->
                     case coordNewModel of wild4 { (,) x3 ds3 ->
                     case x3 of wild5 { GHC.Types.I# y1 ->
                     GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y) y1) } } } } },
                     case ww2 of wild1 { GHC.Types.I# x1 ->
                     case ds1 of wild2 { (,) ds2 y ->
                     case y of wild3 { GHC.Types.I# y1 ->
                     case coordNewModel of wild4 { (,) ds3 y2 ->
                     case y2 of wild5 { GHC.Types.I# y3 ->
                     GHC.Types.I# (GHC.Prim.+# (GHC.Prim.-# x1 y1) y3) } } } } }))
                   x } }) -}
81c6ff2446a8dbcfc73f200a48225e69
  $wdeleteOldCellsForRotate ::
    [Type.CoordCell] -> Type.Field -> Type.Field
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [2] -}
810d7ef06b844609a6cb66661855cc60
  $wfunForSortBy ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><S,U><L,1*U(U)><L,1*U(U)>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Prim.Int#)
                   (ww2 :: GHC.Types.Int)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.<# ww ww1 of lwild {
                   DEFAULT
                   -> case GHC.Prim.==# ww ww1 of lwild1 {
                        DEFAULT -> GHC.Types.GT
                        1#
                        -> case ww2 of wild { GHC.Types.I# x ->
                           case ww3 of wild1 { GHC.Types.I# y ->
                           case GHC.Prim.<# x y of lwild2 {
                             DEFAULT -> GHC.Types.GT 1# -> GHC.Types.LT } } } }
                   1# -> GHC.Types.LT }) -}
fbabcfd3913ecc994b175d1e36b3a096
  $wnumberNextRotateModel :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Prim.Int#) ->
                 case ww of ds {
                   DEFAULT -> GHC.Prim.+# ds 1#
                   0# -> 0#
                   4# -> 1#
                   8# -> 5#
                   12# -> 9#
                   16# -> 13#
                   20# -> 17#
                   24# -> 21#
                   28# -> 25# }) -}
fd088a1f23c496d70899c79ee6ce7274
  $wrotateFigure :: Type.Field -> GHC.Prim.Int# -> Type.Field
  {- Arity: 2, Strictness: <L,U><S,U>, Inline: [2],
     Unfolding: (\ (w :: Type.Field) (ww :: GHC.Prim.Int#) ->
                 let {
                   oldCoord :: Type.CoordFigures
                   = MyProj.getCoordsFromCells
                       (Type.findCellCond
                          w
                          MyProj.findCoordFigure1
                          (GHC.Types.[] @ Type.Cell))
                       (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))
                 } in
                 let {
                   ds :: (GHC.Types.Int, GHC.Types.Int)
                   = case GHC.List.$w!!
                            @ (Type.CoordFigures, Type.CoordCell)
                            Type.createRotateModels
                            ww of wild { (,) ds1 y ->
                     y }
                 } in
                 let {
                   newCoord :: [Type.CoordCell]
                   = MyProj.$wcreateNewCoord
                       ww
                       (case GHC.Base.map
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               (Data.Tuple.fst @ GHC.Types.Int @ GHC.Types.Int)
                               oldCoord of wild {
                          [] -> GHC.List.minimum2
                          : ipv ipv1
                          -> case ipv of ww1 { GHC.Types.I# ww2 ->
                             case GHC.List.$wgo1 ipv1 ww2 of ww3 { DEFAULT ->
                             case ds of wild1 { (,) oldRelMainX oldRelMainY ->
                             case oldRelMainX of wild2 { GHC.Types.I# y ->
                             GHC.Types.I# (GHC.Prim.+# ww3 y) } } } } })
                       (case GHC.Base.map
                               @ (GHC.Types.Int, GHC.Types.Int)
                               @ GHC.Types.Int
                               (Data.Tuple.snd @ GHC.Types.Int @ GHC.Types.Int)
                               oldCoord of wild {
                          [] -> GHC.List.minimum2
                          : ipv ipv1
                          -> case ipv of ww1 { GHC.Types.I# ww2 ->
                             case GHC.List.$wgo1 ipv1 ww2 of ww3 { DEFAULT ->
                             case ds of wild1 { (,) oldRelMainX oldRelMainY ->
                             case oldRelMainY of wild2 { GHC.Types.I# y ->
                             GHC.Types.I# (GHC.Prim.+# ww3 y) } } } } })
                 } in
                 let {
                   fieldDeletedOldCells :: Type.Field
                   = MyProj.$wdeleteOldCellsForRotate oldCoord w
                 } in
                 case MyProj.checkCanRotate fieldDeletedOldCells newCoord of wild {
                   GHC.Types.False -> w
                   GHC.Types.True
                   -> MyProj.setNewCellsdForRotate
                        newCoord
                        (case oldCoord of wild1 {
                           []
                           -> case GHC.List.badHead
                              ret_ty Graphics.Gloss.Internals.Data.Color.Color
                              of {}
                           : x ds1
                           -> case x of wild2 { (,) ds2 y ->
                              case y of ww1 { GHC.Types.I# ww2 ->
                              case ds2 of ww3 { GHC.Types.I# ww4 ->
                              case GHC.List.$w!!
                                     @ Type.Cell
                                     (GHC.List.$w!! @ Type.Line w ww4)
                                     ww2 of wild3 { Type.Cell ds3 ds4 ds5 ds6 ->
                              ds6 } } } } })
                        fieldDeletedOldCells }) -}
557b0888d8e0c689a24dad00a938ec96
  $wupdate ::
    GHC.Base.String
    -> Type.Field
    -> System.Random.StdGen
    -> [Type.NumberFigure]
    -> GHC.Types.Int
    -> [Type.CoordFigures]
    -> [Graphics.Gloss.Internals.Data.Color.Color]
    -> Type.End
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 10,
     Strictness: <L,U><L,U><L,U><L,U><L,U(U)><L,U><L,U><L,U><L,U><L,U(U)>,
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: Type.Field)
                   (ww2 :: System.Random.StdGen)
                   (ww3 :: [Type.NumberFigure])
                   (ww4 :: GHC.Types.Int)
                   (ww5 :: [Type.CoordFigures])
                   (ww6 :: [Graphics.Gloss.Internals.Data.Color.Color])
                   (ww7 :: Type.End)
                   (ww8 :: GHC.Types.Int)
                   (ww9 :: GHC.Types.Int) ->
                 MyProj.runGameLoop1
                   (case ww9 of wild { GHC.Types.I# i ->
                    let {
                      x :: GHC.Prim.Double#
                      = GHC.Prim.+##
                          (GHC.Prim./## (GHC.Prim.int2Double# i) 30.0##)
                          1.0e-4##
                    } in
                    let {
                      n :: GHC.Prim.Int# = GHC.Prim.double2Int# x
                    } in
                    case GHC.Prim.<## (GHC.Prim.int2Double# n) x of lwild {
                      DEFAULT
                      -> case GHC.Prim.<=# n 3# of lwild1 {
                           DEFAULT -> MyProj.update1 1# -> GHC.Types.I# n }
                      1#
                      -> let {
                           x1 :: GHC.Prim.Int# = GHC.Prim.+# n 1#
                         } in
                         case GHC.Prim.<=# x1 3# of lwild1 {
                           DEFAULT -> MyProj.update1 1# -> GHC.Types.I# x1 } } })
                   (\ (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                    (# s, Type.GameState ww ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 #))
                     `cast`
                   (Sym (GHC.Types.N:IO[0] <Type.GameState>_R))) -}
befefd8d6a482ac9e25c396895737e5c
  changeLandCell :: Type.GameState -> Type.GameState
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S,1*U(U,1*U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (game :: Type.GameState) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 Type.GameState
                   ds
                   (MyProj.changeLandCellField ds1)
                   ds2
                   ds3
                   ds4
                   ds5
                   ds6
                   ds7
                   ds8
                   ds9 }) -}
bba93969018fc299677e88e769a754c7
  changeLandCellField :: Type.Field -> Type.Field
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField MyProj.changeLandCellField1 field) -}
1a1768b92ca2b2226c1914267e3471d3
  changeLandCellField1 :: Type.Cell -> Type.Cell
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                 case ds2 of wild1 {
                   DEFAULT -> wild Type.Fly -> Type.Cell ds ds1 Type.Land ds3 } }) -}
3070246e1a156b05fa0a593c7d313ecd
  checkCanAddFigure ::
    Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
bd30c119bd4648dc51ff5076f5637621
  checkCanMoveLeft :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveLeft1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
91fe0593f1e740761dc0442b1602f9cc
  checkCanMoveLeft1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 {
                                     DEFAULT -> go1 ys1
                                     Type.Fly
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild4 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.-#
                                                       wild4
                                                       1#) of wild5 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild6 {
                                               Type.Land
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0]))
                                               Type.Fly -> go1 ys1
                                               Type.Emp -> go1 ys1 } } }
                                          0#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
6ca630c8f3fdcec0ef007269b88edeec
  checkCanMoveRight :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCanMoveRight1
                  `cast`
                (<Type.Field>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
a4b8d5c411262607d7c589f06c71a461
  checkCanMoveRight1 :: Type.Field -> Data.Semigroup.Internal.All
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 letrec {
                   go :: [Type.Line] -> Data.Semigroup.Internal.All
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       []
                       -> GHC.Types.True `cast` (Sym (Data.Semigroup.Internal.N:All[0]))
                       : y ys
                       -> let {
                            exit :: Data.Semigroup.Internal.All <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> Data.Semigroup.Internal.All
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit
                                : y1 ys1
                                -> case y1 of wild2 { Type.Cell ds2 ds3 ds4 ds5 ->
                                   case ds4 of wild3 {
                                     DEFAULT -> go1 ys1
                                     Type.Fly
                                     -> case ds3 of ww5 { GHC.Types.I# ww6 ->
                                        case ww6 of wild4 {
                                          DEFAULT
                                          -> case ds2 of ww2 { GHC.Types.I# ww3 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!! @ Type.Line field ww3)
                                                    (GHC.Prim.+#
                                                       wild4
                                                       1#) of wild5 { Type.Cell ds6 ds7 ds8 ds9 ->
                                             case ds8 of wild6 {
                                               Type.Land
                                               -> GHC.Types.False
                                                    `cast`
                                                  (Sym (Data.Semigroup.Internal.N:All[0]))
                                               Type.Fly -> go1 ys1
                                               Type.Emp -> go1 ys1 } } }
                                          9#
                                          -> GHC.Types.False
                                               `cast`
                                             (Sym (Data.Semigroup.Internal.N:All[0])) } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
93310cc3089b6d4c0fd7abf16706dd20
  checkCanRotate :: Type.Field -> Type.CoordFigures -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
0e93e6be0b6a29f81d8faf31b416040a
  checkCompletedLine :: Type.Line -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.checkCompletedLine1
                  `cast`
                (<Type.Line>_R ->_R Data.Semigroup.Internal.N:All[0]) -}
2e6367af93aa25012b10a39d4ef96439
  checkCompletedLine1 :: Type.Line -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (line :: Type.Line) -> MyProj.checkCompletedLine_go line) -}
2f3c7f508733868360114ef7b4b2d1b8
  checkCompletedLine_go :: [Type.Cell] -> Data.Semigroup.Internal.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b959d0193db1aec096a2cf03b1d564df
  checkFlyCell :: Type.Field -> Type.Cell -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U><S(S(S)LSL),1*U(1*U(1*U),1*U(U),1*U,A)>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 MyProj.$wcheckFlyCell w ww6 ww2 ww3 } }) -}
50cd01ae679e71c56fc626a5d5626e7d
  compareFigure ::
    Type.CoordFigures
    -> GHC.Types.Int
    -> [(Type.CoordFigures, Type.CoordCell)]
    -> (GHC.Types.Int, Type.CoordCell)
  {- Arity: 3, Strictness: <S,1*U><L,U(U)><S,1*U>m, Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Type.CoordFigures)
                   (w1 :: GHC.Types.Int)
                   (w2 :: [(Type.CoordFigures, Type.CoordCell)]) ->
                 case MyProj.$wcompareFigure w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
9d69b45009c50857d43cbe3e603d844b
  countDeletedLines :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S(S),1*U(U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wcountDeletedLines w ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
a2528509739123b0d20b20e30f9b810c
  createCellForMoveLeft :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2, Strictness: <L,1*U><S(LLSL),1*U(U(U),U(U),1*U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of wild {
                   DEFAULT
                   -> case ww2 of ww5 { GHC.Types.I# ww6 ->
                      case ww6 of wild1 {
                        DEFAULT
                        -> case ww1 of ww8 { GHC.Types.I# ww9 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww9)
                                  (GHC.Prim.+# wild1 1#) of wild2 { Type.Cell ds ds1 ds2 ds3 ->
                           case ds2 of wild3 {
                             DEFAULT
                             -> Type.Cell ww8 ww5 Type.Emp Graphics.Gloss.Data.Color.white
                             Type.Fly -> Type.Cell ww8 ww5 Type.Fly ds3 } } }
                        9#
                        -> Type.Cell ww1 ww5 Type.Emp Graphics.Gloss.Data.Color.white } }
                   Type.Land -> Type.Cell ww1 ww2 Type.Land ww4 } }) -}
8200177e8c4290e112865c6aeb99f828
  createCellForMoveRight :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2, Strictness: <L,1*U><S(LLSL),1*U(U(U),U(U),1*U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww3 of wild {
                   DEFAULT
                   -> case ww2 of ww5 { GHC.Types.I# ww6 ->
                      case ww6 of wild1 {
                        DEFAULT
                        -> case ww1 of ww8 { GHC.Types.I# ww9 ->
                           case GHC.List.$w!!
                                  @ Type.Cell
                                  (GHC.List.$w!! @ Type.Line w ww9)
                                  (GHC.Prim.-# wild1 1#) of wild2 { Type.Cell ds ds1 ds2 ds3 ->
                           case ds2 of wild3 {
                             DEFAULT
                             -> Type.Cell ww8 ww5 Type.Emp Graphics.Gloss.Data.Color.white
                             Type.Fly -> Type.Cell ww8 ww5 Type.Fly ds3 } } }
                        0#
                        -> Type.Cell ww1 ww5 Type.Emp Graphics.Gloss.Data.Color.white } }
                   Type.Land -> Type.Cell ww1 ww2 Type.Land ww4 } }) -}
7c8d3385bb51252753c44f7df01628f0
  createCellShiftFigure :: Type.Field -> Type.Cell -> Type.Cell
  {- Arity: 2, Strictness: <L,1*U><S(S(S)LLL),1*U(U(U),U(U),U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: Type.Cell) ->
                 case w1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                 case ww1 of ww5 { GHC.Types.I# ww6 ->
                 case ww6 of wild {
                   DEFAULT
                   -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                      case GHC.List.$w!!
                             @ Type.Cell
                             (GHC.List.$w!! @ Type.Line w (GHC.Prim.-# wild 1#))
                             ww8 of wild1 { Type.Cell ds ds1 ds2 ds3 ->
                      case ds2 of wild2 {
                        Type.Land -> Type.Cell (GHC.Types.I# wild) ww7 ww3 ww4
                        Type.Fly -> Type.Cell (GHC.Types.I# wild) ww7 Type.Fly ds3
                        Type.Emp
                        -> case ww3 of wild3 {
                             DEFAULT -> Type.Cell (GHC.Types.I# wild) ww7 wild3 ww4
                             Type.Fly
                             -> Type.Cell
                                  (GHC.Types.I# wild)
                                  ww7
                                  Type.Emp
                                  Graphics.Gloss.Data.Color.white } } } }
                   0#
                   -> Type.Cell
                        (GHC.Types.I# 0#)
                        ww2
                        Type.Emp
                        Graphics.Gloss.Data.Color.white } } }) -}
ffff6ce843dda36495937212e3aab93a
  createEnd :: Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 2,
     Strictness: <S(LLLLLLLSLL),1*U(U,U,U,U,U(U),U,U,U,U,U(U))><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.createEnd1
                  `cast`
                (<Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
ecd52ed504cba78c16209d3a0e776554
  createEnd1 ::
    Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 2,
     Strictness: <S(LLLLLLLSLL),1*U(U,U,U,U,U(U),U,U,U,U,U(U))><S,U>,
     Unfolding: (\ (game :: Type.GameState)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case game of wild { Type.GameState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ->
                 case ds7 of wild1 {
                   DEFAULT -> (# eta, wild #)
                   Type.FirstEnd
                   -> case (Debug.Trace.trace
                              @ (GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ())
                              (GHC.CString.unpackAppendCString#
                                 MyProj.createEnd7
                                 (case ds9 of ww2 { GHC.Types.I# ww3 ->
                                  case GHC.Show.$wshowSignedInt
                                         0#
                                         ww3
                                         (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                  GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))
                              System.IO.appendFile1
                                `cast`
                              (<GHC.IO.FilePath>_R
                               ->_R <GHC.Base.String>_R
                               ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                              MyProj.createEnd5
                              (GHC.Base.++_$s++
                                 @ GHC.Types.Char
                                 (GHC.CString.unpackAppendCString#
                                    MyProj.createEnd4
                                    (case ds4 of ww2 { GHC.Types.I# ww3 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww3
                                            (GHC.Types.[]
                                               @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                     GHC.Base.++_$s++
                                       @ GHC.Types.Char
                                       MyProj.createEnd2
                                       ww5
                                       ww6 } }))
                                 GHC.Show.$fShow(,)3
                                 (GHC.Show.showLitString ds GHC.Show.$fShow[]1)))
                             `cast`
                           (GHC.Types.N:IO[0] <()>_R)
                             eta of ds10 { (#,#) ipv ipv1 ->
                      (# ipv,
                         Type.GameState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           Type.OldEnd
                           ds8
                           ds9 #) } } }) -}
2c3e7d4fcb7974bfee20cf821e1c5368
  createEnd2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.createEnd3) -}
1172a44825b6cca46e43ce4398da356d
  createEnd3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("\n"#) -}
dfa5eefac29c8612569471676d292357
  createEnd4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" - "#) -}
73fac93f872850ffd99ffb80fef5ab63
  createEnd5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MyProj.createEnd6) -}
bd56e965735cb362f91ee29a97ffdf00
  createEnd6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("result"#) -}
7a9018e29d87777e3b88eeed4b3ca953
  createEnd7 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("append"#) -}
3a67ca68ebc00c2eb68e5f94ee299439
  createNewCoord ::
    GHC.Types.Int -> Type.CoordCell -> [Type.CoordCell]
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><S,1*U(U(U),U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Type.CoordCell) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { (,) ww3 ww4 ->
                 MyProj.$wcreateNewCoord ww1 ww3 ww4 } }) -}
8b49fc87d0bb38b2fbedff3808361a4c
  deleteLineWithNumber :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <S,U><L,U(U)>,
     Unfolding: (\ (field :: Type.Field)
                   (numDeletedLine :: GHC.Types.Int) ->
                 Type.mapField
                   (\ (c :: Type.Cell) ->
                    case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                    case ds of wild1 { GHC.Types.I# x ->
                    case numDeletedLine of wild2 { GHC.Types.I# y ->
                    case GHC.Prim.># x y of lwild {
                      DEFAULT
                      -> case x of wild3 {
                           DEFAULT
                           -> let {
                                hc :: Type.Cell
                                = case ds1 of ww2 { GHC.Types.I# ww3 ->
                                  GHC.List.$w!!
                                    @ Type.Cell
                                    (GHC.List.$w!! @ Type.Line field (GHC.Prim.-# wild3 1#))
                                    ww3 }
                              } in
                              Type.Cell wild1 ds1 (Type.getCellType hc) (Type.getCellColor hc)
                           0#
                           -> Type.Cell wild1 ds1 Type.Emp Graphics.Gloss.Data.Color.white }
                      1# -> wild } } } })
                   field) -}
f9b2d9fd0d6da7eb83703fc58235f928
  deleteLines :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,1*U(U),U,U,A,U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 Type.GameState
                   ww1
                   (MyProj.deleteLinesFromField ww2)
                   ww3
                   ww4
                   (case ww5 of wild { GHC.Types.I# x ->
                    case MyProj.$wcountDeletedLines ww2 0# of ww11 { DEFAULT ->
                    GHC.Types.I# (GHC.Prim.+# x ww11) } })
                   ww6
                   ww7
                   Type.Game
                   ww9
                   ww10 }) -}
8c73918aa0b422730bd6e6dfd49a0d06
  deleteLinesFromField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U> -}
b7b192abf032c494214f039fcd4cc5d6
  deleteOldCellsForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,A><L,U>, Inline: [2],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: [Type.CoordCell])
                   (w1 :: Graphics.Gloss.Internals.Data.Color.Color)
                   (w2 :: Type.Field) ->
                 MyProj.$wdeleteOldCellsForRotate w w2) -}
0e3e10f129114925edb427f794974549
  findCoordFigure :: Type.Field -> Type.CoordFigures
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 MyProj.getCoordsFromCells
                   (Type.findCellCond
                      field
                      MyProj.findCoordFigure1
                      (GHC.Types.[] @ Type.Cell))
                   (GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int))) -}
da54af7f7ae1984977df733072be8d74
  findCoordFigure1 :: Type.Cell -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (c :: Type.Cell) ->
                 case c of wild { Type.Cell ds ds1 ds2 ds3 ->
                 case ds2 of wild1 {
                   DEFAULT -> GHC.Types.False Type.Fly -> GHC.Types.True } }) -}
ac17f82765c06cfcb67bf68f1b7c15c4
  funForSortBy ::
    (GHC.Types.Int, GHC.Types.Int)
    -> (GHC.Types.Int, GHC.Types.Int) -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S,1*U(1*U(U),1*U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (GHC.Types.Int, GHC.Types.Int))
                   (w1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 case w1 of ww7 { (,) ww8 ww9 ->
                 MyProj.$wfunForSortBy ww4 ww6 ww8 ww9 } } } }) -}
522fc2ecd907edd589dafee4d6756ad6
  gameLoop ::
    GHC.Types.IO Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 2,
     Strictness: <C(S(SS(LLLLLLLSLL))),1*C1(U(U,1*U(U,U,U,U,U(U),U,U,U,U,U(U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.gameLoop1
                  `cast`
                (<GHC.Types.IO Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
a3586971c1702ad04570b69fba325bbb
  gameLoop1 ::
    GHC.Types.IO Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 2,
     Strictness: <C(S(SS(LLLLLLLSLL))),1*C1(U(U,1*U(U,U,U,U,U(U),U,U,U,U,U(U))))><S,U>,
     Unfolding: (\ (g :: GHC.Types.IO Type.GameState)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case g `cast` (GHC.Types.N:IO[0] <Type.GameState>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 case ipv1 of wild { Type.GameState ds ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 case ds8 of wild1 {
                   Type.Game
                   -> case MyProj.haveFlyFigure ds2 of wild2 {
                        GHC.Types.False
                        -> (# ipv,
                              case ds4 of wild3 {
                                [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                                : x ds11
                                -> case x of ww { GHC.Types.I# ww1 ->
                                   let {
                                     coordNextFigure :: Type.CoordFigures
                                     = GHC.List.$w!! @ Type.CoordFigures ds6 ww1
                                   } in
                                   let {
                                     ds12 :: Type.Field
                                     = Type.mapField MyProj.changeLandCellField1 ds2
                                   } in
                                   let {
                                     ww2 :: Type.Field = MyProj.deleteLinesFromField ds12
                                   } in
                                   let {
                                     ww3 :: GHC.Types.Int
                                     = case ds5 of wild4 { GHC.Types.I# x1 ->
                                       case MyProj.$wcountDeletedLines ds12 0# of ww4 { DEFAULT ->
                                       GHC.Types.I# (GHC.Prim.+# x1 ww4) } }
                                   } in
                                   case MyProj.checkCanAddFigure ww2 coordNextFigure of wild4 {
                                     GHC.Types.False
                                     -> Type.GameState
                                          ds
                                          ww2
                                          ds3
                                          wild3
                                          ww3
                                          ds6
                                          ds7
                                          Type.FirstEnd
                                          ds9
                                          (case ds10 of wild5 { GHC.Types.I# x1 ->
                                           GHC.Types.I# (GHC.Prim.+# x1 1#) })
                                     GHC.Types.True
                                     -> Type.GameState
                                          ds
                                          (MyProj.newFigureOnField
                                             ww2
                                             coordNextFigure
                                             (GHC.List.$w!!
                                                @ Graphics.Gloss.Internals.Data.Color.Color
                                                ds7
                                                ww1))
                                          ds3
                                          ds11
                                          ww3
                                          ds6
                                          ds7
                                          Type.Game
                                          (case ww1 of wild5 {
                                             DEFAULT
                                             -> GHC.Types.I# (GHC.Prim.-# (GHC.Prim.*# wild5 4#) 3#)
                                             0# -> MyProj.gameLoop2 })
                                          (case ds10 of wild5 { GHC.Types.I# x1 ->
                                           GHC.Types.I# (GHC.Prim.+# x1 1#) }) } } } #)
                        GHC.Types.True
                        -> (# ipv,
                              Type.GameState
                                ds
                                (MyProj.shiftFigureOnField ds2)
                                ds3
                                ds4
                                ds5
                                ds6
                                ds7
                                Type.Game
                                ds9
                                (case ds10 of wild3 { GHC.Types.I# x ->
                                 GHC.Types.I# (GHC.Prim.+# x 1#) }) #) }
                   Type.FirstEnd -> MyProj.createEnd1 wild ipv
                   Type.OldEnd -> MyProj.createEnd1 wild ipv } } }) -}
047a953071f4cf33f13e9c9fea125134
  gameLoop2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
5403dca58583d32beae77d97a580ae3f
  getCoordsFromCells ::
    [Type.Cell]
    -> [(GHC.Types.Int, GHC.Types.Int)]
    -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
335e95840b4fa72807542fec448ca8b4
  handleEvent ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U,U,U,U,U,U,U,U(U),U)><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.handleEvent1
                  `cast`
                (<Graphics.Gloss.Internals.Interface.Event.Event>_R
                 ->_R <Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
4cd68ea25641be90a56611d4e46de080
  handleEvent1 ::
    Graphics.Gloss.Internals.Interface.Event.Event
    -> Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U,U,U,U,U,U,U,U,U(U),U)><S,U>,
     Unfolding: (\ (ds :: Graphics.Gloss.Internals.Interface.Event.Event)
                   (game :: Type.GameState)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                 case ds of wild {
                   DEFAULT -> (# eta, game #)
                   Graphics.Gloss.Internals.Interface.Event.EventKey ds1 ds2 ds3 ds4
                   -> case ds1 of wild1 {
                        DEFAULT -> (# eta, game #)
                        Graphics.Gloss.Internals.Interface.Backend.Types.SpecialKey ds5
                        -> case ds5 of wild2 {
                             DEFAULT -> (# eta, game #)
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyUp
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     case ds13 of wild5 {
                                       Type.Game
                                       -> (# eta,
                                             Type.GameState
                                               ds6
                                               (MyProj.rotateFigure ds7 ds14)
                                               ds8
                                               ds9
                                               ds10
                                               ds11
                                               ds12
                                               Type.Game
                                               (MyProj.numberNextRotateModel ds14)
                                               ds15 #)
                                       Type.FirstEnd -> (# eta, wild4 #)
                                       Type.OldEnd -> (# eta, wild4 #) } }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyLeft
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     case ds13 of wild5 {
                                       Type.Game
                                       -> (# eta,
                                             Type.GameState
                                               ds6
                                               (MyProj.moveLeft ds7)
                                               ds8
                                               ds9
                                               ds10
                                               ds11
                                               ds12
                                               Type.Game
                                               ds14
                                               ds15 #)
                                       Type.FirstEnd -> (# eta, wild4 #)
                                       Type.OldEnd -> (# eta, wild4 #) } }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyRight
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     case ds13 of wild5 {
                                       Type.Game
                                       -> (# eta,
                                             Type.GameState
                                               ds6
                                               (MyProj.moveRight ds7)
                                               ds8
                                               ds9
                                               ds10
                                               ds11
                                               ds12
                                               Type.Game
                                               ds14
                                               ds15 #)
                                       Type.FirstEnd -> (# eta, wild4 #)
                                       Type.OldEnd -> (# eta, wild4 #) } }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) }
                             Graphics.Gloss.Internals.Interface.Backend.Types.KeyEnter
                             -> case ds2 of wild3 {
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Down
                                  -> case game of wild4 { Type.GameState ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ->
                                     (# eta,
                                        Type.GameState
                                          ds6
                                          Type.createField
                                          ds8
                                          (case ds9 of wild5 {
                                             []
                                             -> case GHC.List.scanl2
                                                ret_ty [Type.NumberFigure]
                                                of {}
                                             : ds16 xs
                                             -> case xs of wild6 {
                                                  [] -> GHC.List.scanl2 @ Type.NumberFigure
                                                  : ds17 xs1 -> xs1 } })
                                          MyProj.gameLoop2
                                          ds11
                                          ds12
                                          Type.Game
                                          MyProj.handleEvent2
                                          MyProj.gameLoop2 #) }
                                  Graphics.Gloss.Internals.Interface.Backend.Types.Up
                                  -> (# eta, game #) } } } }) -}
7a87d2fcae9dd9448fdb7e26d7e84dca
  handleEvent2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 28#) -}
a01ef3d4afefa090a66ca308fc91738c
  haveFlyFigure :: Type.Field -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 let {
                   exit :: GHC.Types.Bool <join 0>
                   = (MyProj.haveFlyFigure_go field)
                       `cast`
                     (Data.Semigroup.Internal.N:Any[0])
                 } in
                 letrec {
                   go :: [Type.Line] -> GHC.Types.Bool
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Type.Line]) ->
                     case ds of wild {
                       [] -> exit
                       : y ys
                       -> let {
                            exit1 :: GHC.Types.Bool <join 0> = go ys
                          } in
                          letrec {
                            go1 :: [Type.Cell] -> GHC.Types.Bool
                              <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Type.Cell]) ->
                              case ds1 of wild1 {
                                [] -> exit1
                                : y1 ys1
                                -> case y1 of ww { Type.Cell ww1 ww2 ww3 ww4 ->
                                   case ww1 of ww5 { GHC.Types.I# ww6 ->
                                   case ww6 of wild2 {
                                     DEFAULT
                                     -> case ww3 of wild3 {
                                          DEFAULT -> go1 ys1
                                          Type.Fly
                                          -> case ww2 of ww7 { GHC.Types.I# ww8 ->
                                             case GHC.List.$w!!
                                                    @ Type.Cell
                                                    (GHC.List.$w!!
                                                       @ Type.Line
                                                       field
                                                       (GHC.Prim.+# wild2 1#))
                                                    ww8 of wild4 { Type.Cell ds2 ds3 ds4 ds5 ->
                                             case ds4 of wild5 {
                                               Type.Land -> GHC.Types.False
                                               Type.Fly -> go1 ys1
                                               Type.Emp -> go1 ys1 } } } }
                                     14#
                                     -> case ww3 of wild3 {
                                          DEFAULT -> go1 ys1 Type.Fly -> GHC.Types.False } } } } }
                          } in
                          go1 y }
                 } in
                 go field) -}
52f4e3848202a31b867b6db2f903db5e
  haveFlyFigure_go :: [Type.Line] -> Data.Semigroup.Internal.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
1526fbbcbff79a0bd624da5d685b735d
  moveLeft :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveLeft1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveLeft field) field }) -}
54b8644e29facc39f492e0b360965d32
  moveRight :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (field :: Type.Field) ->
                 case (MyProj.checkCanMoveRight1 field)
                        `cast`
                      (Data.Semigroup.Internal.N:All[0]) of wild {
                   GHC.Types.False -> field
                   GHC.Types.True
                   -> Type.mapField (MyProj.createCellForMoveRight field) field }) -}
40fdab99fe0a6b36182485d151bf2d54
  newFigureOnField ::
    Type.Field
    -> Type.CoordFigures
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U> -}
be23dee7b50c82ed1588d725f2d4703f
  newFigureOnGame :: Type.GameState -> Type.GameState
  {- Arity: 1,
     Strictness: <S(LLLSLSLLLL),1*U(U,U,U,1*U,U,U,U,A,U,1*U(U))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.GameState) ->
                 case w of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 case ww4 of wild {
                   [] -> case GHC.List.badHead ret_ty Type.GameState of {}
                   : x ds1
                   -> case x of ww11 { GHC.Types.I# ww12 ->
                      let {
                        coordNextFigure :: Type.CoordFigures
                        = GHC.List.$w!! @ Type.CoordFigures ww6 ww12
                      } in
                      case MyProj.checkCanAddFigure ww2 coordNextFigure of wild1 {
                        GHC.Types.False
                        -> Type.GameState
                             ww1
                             ww2
                             ww3
                             wild
                             ww5
                             ww6
                             ww7
                             Type.FirstEnd
                             ww9
                             (case ww10 of wild2 { GHC.Types.I# x1 ->
                              GHC.Types.I# (GHC.Prim.+# x1 1#) })
                        GHC.Types.True
                        -> Type.GameState
                             ww1
                             (MyProj.newFigureOnField
                                ww2
                                coordNextFigure
                                (GHC.List.$w!!
                                   @ Graphics.Gloss.Internals.Data.Color.Color
                                   ww7
                                   ww12))
                             ww3
                             ds1
                             ww5
                             ww6
                             ww7
                             Type.Game
                             (case ww12 of wild2 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.-# (GHC.Prim.*# wild2 4#) 3#)
                                0# -> MyProj.gameLoop2 })
                             (case ww10 of wild2 { GHC.Types.I# x1 ->
                              GHC.Types.I# (GHC.Prim.+# x1 1#) }) } } } }) -}
8f2b2cab448bff1e226b778b6729956d
  numCompLine :: Type.Field -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
a86d715edde92dd4d3fa92939bb7c9d7
  numberNextRotateModel :: GHC.Types.Int -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case MyProj.$wnumberNextRotateModel ww1 of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
5653658a171639fae8fc8264195ce00a
  rotateFigure :: Type.Field -> GHC.Types.Int -> Type.Field
  {- Arity: 2, Strictness: <L,U><S(S),1*U(U)>, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Field) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 MyProj.$wrotateFigure w ww1 }) -}
f712890a5fd5c659611903c06feb1229
  runGameLoop ::
    GHC.Types.Int
    -> GHC.Types.IO Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 3,
     Strictness: <L,1*U(1*U)><C(S(SS)),C(U(U,U(U,U,U,U,U(U),U,U,U,U,U(U))))><S,U>,
     Unfolding: InlineRule (0, True, True)
                MyProj.runGameLoop1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R <GHC.Types.IO Type.GameState>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) -}
0be2267584cd28eba0b91f18b6988cfc
  runGameLoop1 ::
    GHC.Types.Int
    -> GHC.Types.IO Type.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Type.GameState #)
  {- Arity: 3,
     Strictness: <L,1*U(1*U)><C(S(SS)),C(U(U,U(U,U,U,U,U(U),U,U,U,U,U(U))))><S,U> -}
8b7f615a53ad04619609c811c5b614e8
  setNewCellsdForRotate ::
    [Type.CoordCell]
    -> Graphics.Gloss.Internals.Data.Color.Color
    -> Type.Field
    -> Type.Field
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
6a983da293c5c1cfd59f32c600559fc1
  shiftFigure :: Type.GameState -> Type.GameState
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U,U,U,A,U,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Type.GameState) ->
                 case ds of wild { Type.GameState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ->
                 Type.GameState
                   ds1
                   (MyProj.shiftFigureOnField ds2)
                   ds3
                   ds4
                   ds5
                   ds6
                   ds7
                   Type.Game
                   ds9
                   (case ds10 of wild1 { GHC.Types.I# x ->
                    GHC.Types.I# (GHC.Prim.+# x 1#) }) }) -}
721e52e726a912d44a8ea0840054efbe
  shiftFigureOnField :: Type.Field -> Type.Field
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (field :: Type.Field) ->
                 Type.mapField
                   (\ (c :: Type.Cell) -> MyProj.createCellShiftFigure field c)
                   field) -}
e42b00b3c156e5a7b594e0fc32eafe6a
  update ::
    GHC.Types.Float -> Type.GameState -> GHC.Types.IO Type.GameState
  {- Arity: 2, Strictness: <L,A><S,1*U(U,U,U,U,U(U),U,U,U,U,U(U))>,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Float) (w1 :: Type.GameState) ->
                 case w1 of ww { Type.GameState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ->
                 (MyProj.$wupdate ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10)
                   `cast`
                 (Sym (GHC.Types.N:IO[0] <Type.GameState>_R)) }) -}
7b10673455fa3e0c90d4b5e309e6c905
  update1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 3#) -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

